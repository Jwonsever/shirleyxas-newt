//
// This code was generated by Enunciate.
// http://enunciate.codehaus.org/
//
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <libxml/xmlwriter.h>
#include <libxml/xmlreader.h>

#ifndef DEBUG_ENUNCIATE
#define DEBUG_ENUNCIATE 0
#endif

#ifndef ENUNCIATE_C_UTILITIES
#define ENUNCIATE_C_UTILITIES

/**
 * A basic xml node, used when (de)serializing unknown or "any" xml type.
 * We can't use the libxml xmlNodePtr because we can't reliably "free" it.
 */
struct xmlBasicNode {
  /**
   * The (local) name of the node.
   */
  xmlChar *name;

  /**
   * The namespace of the node.
   */
  xmlChar *ns;

  /**
   * The namespace prefix of the node.
   */
  xmlChar *prefix;

  /**
   * The (text) value of the node.
   */
  xmlChar *value;

  /**
   * The child elements of the node.
   */
  struct xmlBasicNode *child_elements;

  /**
   * The attributes of the node.
   */
  struct xmlBasicNode *attributes;

  /**
   * The next sibling (for a list of nodes).
   */
  struct xmlBasicNode *sibling;
};

/*******************xml utilities************************************/

static int xmlTextReaderAdvanceToNextStartOrEndElement(xmlTextReaderPtr reader) {
  int status = xmlTextReaderRead(reader);
  while (status && xmlTextReaderNodeType(reader) != XML_READER_TYPE_ELEMENT && xmlTextReaderNodeType(reader) != XML_READER_TYPE_END_ELEMENT) {
    status = xmlTextReaderRead(reader);
  }
  return status;
}

static int xmlTextReaderSkipElement(xmlTextReaderPtr reader) {
  int status = xmlTextReaderNext(reader);
  while (status && xmlTextReaderNodeType(reader) != XML_READER_TYPE_ELEMENT && xmlTextReaderNodeType(reader) != XML_READER_TYPE_END_ELEMENT) {
    status = xmlTextReaderRead(reader);
  }
  return status;
}

static xmlChar *xmlTextReaderReadEntireNodeValue(xmlTextReaderPtr reader) {
  xmlChar *buffer = calloc(1, sizeof(xmlChar));
  const xmlChar *snippet;
  int status;
  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ATTRIBUTE) {
    return xmlTextReaderValue(reader);
  }
  else if (xmlTextReaderIsEmptyElement(reader) == 0) {
    status = xmlTextReaderRead(reader);
    while (status && (xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT || xmlTextReaderNodeType(reader) == XML_READER_TYPE_CDATA || xmlTextReaderNodeType(reader) == XML_READER_TYPE_ENTITY_REFERENCE)) {
      snippet = xmlTextReaderConstValue(reader);
      buffer = realloc(buffer, (xmlStrlen(buffer) + xmlStrlen(snippet) + 1) * sizeof(xmlChar));
      xmlStrcat(buffer, snippet);
      status = xmlTextReaderRead(reader);
    }
  }
  return buffer;
}

/*******************base 64 utilities************************************/

/*
 * Base64 Translation Table as described in RFC1113.
 *
 * This code was graciously ripped from http://base64.sourceforge.net
 */
static const char cb64[]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

/*
 * Base64 Translation Table to decode (created by author)
 *
 * This code was graciously ripped from http://base64.sourceforge.net
 */
static const char cd64[]="|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\]^_`abcdefghijklmnopq";

/*
 * encode 3 8-bit binary bytes as 4 '6-bit' characters
 *
 * This code was graciously ripped from http://base64.sourceforge.net
 *
 * @param in the block to encode
 * @param out the block to encode to
 * @param len the length of the 'in' block.
 */
static void _encode_base64_block(unsigned char in[3], unsigned char out[4], int len) {
  out[0] = cb64[ in[0] >> 2 ];
  out[1] = cb64[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
  out[2] = (unsigned char) (len > 1 ? cb64[ ((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=');
  out[3] = (unsigned char) (len > 2 ? cb64[ in[2] & 0x3f ] : '=');
}

/*
 * decode 4 '6-bit' characters into 3 8-bit binary bytes
 *
 * This code was graciously ripped from http://base64.sourceforge.net
 */
static void _decode_base64_block( unsigned char in[4], unsigned char out[3] )
{
    out[ 0 ] = (unsigned char ) (in[0] << 2 | in[1] >> 4);
    out[ 1 ] = (unsigned char ) (in[1] << 4 | in[2] >> 2);
    out[ 2 ] = (unsigned char ) (((in[2] << 6) & 0xc0) | in[3]);
}

/*
 * base64 encode a stream adding padding and line breaks as per spec.
 *
 * This code was graciously ripped from http://base64.sourceforge.net
 *
 * @param instream The stream to encode.
 * @param insize The size of the stream to encode.
 * @return The encoded string.
 */
xmlChar *_encode_base64(unsigned char *instream, int insize) {
  unsigned char in[3];
  unsigned char out[4];
  xmlChar *encoded;
  int i, in_index = 0, out_index = 0, blocklen;

  if (insize == 0) {
    return BAD_CAST "\0";
  }

  encoded = calloc(((insize / 3) * 4) + 10, sizeof(xmlChar));
  while (in_index <= insize) {
    blocklen = 0;
    for (i = 0; i < 3; i++) {
      in[i] = instream[in_index++];
      if (in_index <= insize) {
        blocklen++;
      }
      else {
        in[i] = 0;
      }
    }
    if (blocklen) {
      _encode_base64_block(in, out, blocklen);
      for( i = 0; i < 4; i++ ) {
        encoded[out_index++] = out[i];
      }
    }
  }

  return encoded;
}

/*
 * Decode a base64 encoded stream discarding padding, line breaks and noise
 *
 * This code was graciously ripped from http://base64.sourceforge.net
 *
 * @param invalue The string to decode.
 * @param outsize Holder for the length of the returned data.
 * @return The decoded data.
 */
unsigned char *_decode_base64( const xmlChar *invalue, int *outsize ) {
  xmlChar in[4];
  unsigned char out[3], v;
  int i, in_index = 0, out_index = 0, blocklen;
  unsigned char *outstream;

  if (invalue == NULL) {
    return NULL;
  }

  outstream = calloc(((xmlStrlen(invalue) / 4) * 3) + 1, sizeof(unsigned char));
  while (invalue[in_index] != '\0') {
    for (blocklen = 0, i = 0; i < 4 && invalue[in_index]; i++) {
      v = 0;
      while (invalue[in_index] != '\0' && v == 0) {
        v = (unsigned char) invalue[in_index++];
        v = (unsigned char) ((v < 43 || v > 122) ? 0 : cd64[ v - 43 ]);
        if (v) {
          v = (unsigned char) ((v == '$') ? 0 : v - 61);
        }
      }

      if (invalue[in_index] != '\0') {
        blocklen++;
        if (v) {
          in[i] = (unsigned char) (v - 1);
        }
      }
      else {
        in[i] = 0;
      }
    }

    if (blocklen) {
      _decode_base64_block( in, out );
      for( i = 0; i < blocklen - 1; i++ ) {
        outstream[out_index++] = out[i];
      }
    }
  }

  if (outsize != NULL) {
    *outsize = out_index;
  }

  return outstream;
}

#endif /* ENUNCIATE_C_UTILITIES */

#ifndef BASIC_XML_FUNCTIONS_Xs
#define BASIC_XML_FUNCTIONS_Xs

/*******************xs:boolean************************************/

/**
 * Read a boolean value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to 1 if "true" was read. pointer to 0 otherwise.
 */
static int *xmlTextReaderReadXsBooleanType(xmlTextReaderPtr reader) {
  xmlChar *nodeValue = xmlTextReaderReadEntireNodeValue(reader);
  int *value = malloc(sizeof(int));
  *value = (xmlStrcmp(BAD_CAST "true", nodeValue) == 0) ? 1 : 0;
  free(nodeValue);
  return value;
}

/**
 * Write a boolean value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsBooleanType(xmlTextWriterPtr writer, int *value) {
  if (*value) {
    return xmlTextWriterWriteString(writer, BAD_CAST "false");
  }
  else {
    return xmlTextWriterWriteString(writer, BAD_CAST "true");
  }
}

/**
 * Frees a boolean type from memory.
 *
 * @param value The value to free.
 */
static void freeXsBooleanType(int *value) {
  //no-op
}

/*******************xs:byte************************************/

/**
 * Read a byte value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the byte.
 */
static unsigned char *xmlTextReaderReadXsByteType(xmlTextReaderPtr reader) {
  xmlChar *nodeValue = xmlTextReaderReadEntireNodeValue(reader);
  unsigned char *value = malloc(sizeof(unsigned char));
  *value = (unsigned char) atoi((char *) nodeValue);
  free(nodeValue);
  return value;
}

/**
 * Write a byte value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsByteType(xmlTextWriterPtr writer, unsigned char *value) {
  return xmlTextWriterWriteFormatString(writer, "%i", *value);
}

/**
 * Frees a byte type from memory.
 *
 * @param value The value to free.
 */
static void freeXsByteType(unsigned char *value) {
  //no-op
}

/*******************xs:double************************************/

/**
 * Read a double value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the double.
 */
static double *xmlTextReaderReadXsDoubleType(xmlTextReaderPtr reader) {
  xmlChar *nodeValue = xmlTextReaderReadEntireNodeValue(reader);
  double *value = malloc(sizeof(double));
  *value = atof((char *) nodeValue);
  free(nodeValue);
  return value;
}

/**
 * Write a double value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsDoubleType(xmlTextWriterPtr writer, double *value) {
  return xmlTextWriterWriteFormatString(writer, "%f", *value);
}

/**
 * Frees a double type from memory.
 *
 * @param value The value to free.
 */
static void freeXsDoubleType(double *value) {
  //no-op
}

/*******************xs:float************************************/

/**
 * Read a float value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the float.
 */
static float *xmlTextReaderReadXsFloatType(xmlTextReaderPtr reader) {
  xmlChar *nodeValue = xmlTextReaderReadEntireNodeValue(reader);
  float *value = malloc(sizeof(float));
  *value = atof((char *)nodeValue);
  free(nodeValue);
  return value;
}

/**
 * Write a float value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsFloatType(xmlTextWriterPtr writer, float *value) {
  return xmlTextWriterWriteFormatString(writer, "%f", *value);
}

/**
 * Frees a float type from memory.
 *
 * @param value The value to free.
 */
static void freeXsFloatType(float *value) {
  //no-op
}

/*******************xs:int************************************/

/**
 * Read a int value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @param value The value to be written.
 * @return pointer to the int.
 */
static int *xmlTextReaderReadXsIntType(xmlTextReaderPtr reader) {
  xmlChar *nodeValue = xmlTextReaderReadEntireNodeValue(reader);
  int *value = malloc(sizeof(int));
  *value = atoi((char *)nodeValue);
  free(nodeValue);
  return value;
}

/**
 * Write a int value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsIntType(xmlTextWriterPtr writer, int *value) {
  return xmlTextWriterWriteFormatString(writer, "%i", *value);
}

/**
 * Frees a int type from memory.
 *
 * @param value The value to free.
 */
static void freeXsIntType(int *value) {
  //no-op
}

/*******************xs:long************************************/

/**
 * Read a long value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the long.
 */
static long *xmlTextReaderReadXsLongType(xmlTextReaderPtr reader) {
  xmlChar *nodeValue = xmlTextReaderReadEntireNodeValue(reader);
  long *value = malloc(sizeof(long));
  *value = atol((char *)nodeValue);
  free(nodeValue);
  return value;
}

/**
 * Write a long value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsLongType(xmlTextWriterPtr writer, long *value) {
  return xmlTextWriterWriteFormatString(writer, "%ld", *value);
}

/**
 * Frees a long type from memory.
 *
 * @param value The value to free.
 */
static void freeXsLongType(long *value) {
  //no-op
}

/*******************xs:short************************************/

/**
 * Read a short value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the short.
 */
static short *xmlTextReaderReadXsShortType(xmlTextReaderPtr reader) {
  xmlChar *nodeValue = xmlTextReaderReadEntireNodeValue(reader);
  short *value = malloc(sizeof(short));
  *value = atoi((char *)nodeValue);
  return value;
}

/**
 * Write a short value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsShortType(xmlTextWriterPtr writer, short *value) {
  return xmlTextWriterWriteFormatString(writer, "%hi", *value);
}

/**
 * Frees a short type from memory.
 *
 * @param value The value to free.
 */
static void freeXsShortType(short *value) {
  //no-op
}

/*******************xs:string************************************/

/**
 * Read a string value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the string.
 */
static xmlChar *xmlTextReaderReadXsStringType(xmlTextReaderPtr reader) {
  return xmlTextReaderReadEntireNodeValue(reader);
}

/**
 * Write a string value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsStringType(xmlTextWriterPtr writer, xmlChar *value) {
  return xmlTextWriterWriteString(writer, value);
}

/**
 * Frees a string type from memory.
 *
 * @param value The value to free.
 */
static void freeXsStringType(xmlChar *value) {
  //no-op
}

/*******************xs:ID************************************/

/**
 * Read a ID value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the ID.
 */
static xmlChar *xmlTextReaderReadXsIDType(xmlTextReaderPtr reader) {
  return xmlTextReaderReadXsStringType(reader);
}

/**
 * Write a ID value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsIDType(xmlTextWriterPtr writer, xmlChar *value) {
  return xmlTextWriterWriteString(writer, value);
}

/**
 * Frees a ID type from memory.
 *
 * @param value The value to free.
 */
static void freeXsIDType(xmlChar *value) {
  freeXsStringType(value);
}

/*******************xs:IDREF************************************/

/**
 * Read a IDREF value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the IDREF.
 */
static xmlChar *xmlTextReaderReadXsIDREFType(xmlTextReaderPtr reader) {
  return xmlTextReaderReadXsStringType(reader);
}

/**
 * Write a IDREF value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsIDREFType(xmlTextWriterPtr writer, xmlChar *value) {
  return xmlTextWriterWriteString(writer, value);
}

/**
 * Frees a IDREF type from memory.
 *
 * @param value The value to free.
 */
static void freeXsIDREFType(xmlChar *value) {
  freeXsStringType(value);
}

/*******************xs:integer************************************/

/**
 * Read a (big) integer value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the integer.
 */
static xmlChar *xmlTextReaderReadXsIntegerType(xmlTextReaderPtr reader) {
  return xmlTextReaderReadXsStringType(reader);
}

/**
 * Write a integer value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsIntegerType(xmlTextWriterPtr writer, xmlChar *value) {
  return xmlTextWriterWriteString(writer, value);
}

/**
 * Frees a integer type from memory.
 *
 * @param value The value to free.
 */
static void freeXsIntegerType(xmlChar *value) {
  freeXsStringType(value);
}

/*******************xs:decimal************************************/

/**
 * Read a (big) decimal value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the decimal.
 */
static xmlChar *xmlTextReaderReadXsDecimalType(xmlTextReaderPtr reader) {
  return xmlTextReaderReadXsStringType(reader);
}

/**
 * Write a decimal value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsDecimalType(xmlTextWriterPtr writer, xmlChar *value) {
  return xmlTextWriterWriteString(writer, value);
}

/**
 * Frees a decimal type from memory.
 *
 * @param value The value to free.
 */
static void freeXsDecimalType(xmlChar *value) {
  freeXsStringType(value);
}

/*******************xs:duration************************************/

/**
 * Read a duration value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the duration.
 */
static xmlChar *xmlTextReaderReadXsDurationType(xmlTextReaderPtr reader) {
  return xmlTextReaderReadXsStringType(reader);
}

/**
 * Write a duration value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsDurationType(xmlTextWriterPtr writer, xmlChar *value) {
  return xmlTextWriterWriteString(writer, value);
}

/**
 * Frees a duration type from memory.
 *
 * @param value The value to free.
 */
static void freeXsDurationType(xmlChar *value) {
  freeXsStringType(value);
}

/*******************xs:QName************************************/

/**
 * Read a QName value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the QName.
 */
static xmlChar *xmlTextReaderReadXsQNameType(xmlTextReaderPtr reader) {
  return xmlTextReaderReadXsStringType(reader);
}

/**
 * Write a QName value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsQNameType(xmlTextWriterPtr writer, xmlChar *value) {
  return xmlTextWriterWriteString(writer, value);
}

/**
 * Frees a QName type from memory.
 *
 * @param value The value to free.
 */
static void freeXsQNameType(xmlChar *value) {
  freeXsStringType(value);
}

/*******************xs:anyURI************************************/

/**
 * Read a anyURI value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the anyURI.
 */
static xmlChar *xmlTextReaderReadXsAnyURIType(xmlTextReaderPtr reader) {
  return xmlTextReaderReadXsStringType(reader);
}

/**
 * Write a anyURI value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsAnyURIType(xmlTextWriterPtr writer, xmlChar *value) {
  return xmlTextWriterWriteString(writer, value);
}

/**
 * Frees a anyURI type from memory.
 *
 * @param value The value to free.
 */
static void freeXsAnyURIType(xmlChar *value) {
  freeXsStringType(value);
}

/*******************xs:dateTime************************************/

/**
 * Read a dateTime value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the dateTime.
 */
static struct tm *xmlTextReaderReadXsDateTimeType(xmlTextReaderPtr reader) {
  struct tm * time = calloc(1, sizeof(struct tm));
  xmlChar *timevalue = xmlTextReaderReadEntireNodeValue(reader);
  int success = 0, index = 0, token_index = 0, len = xmlStrlen(timevalue), offset_hours = 0, offset_min = 0;
  char token[len];

  //date time format: yyyy-mm-ddThh:MM:ss+oo:oo
  //go to first '-' character.
  token_index = 0;
  while (index < len && timevalue[index] != '-') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_year = atoi(token) - 1900;
  if (token_index > 0) {
    success++; //assume 'year' was successfully read.
    index++;
  }

  //go to next '-' character.
  token_index = 0;
  while (index < len && timevalue[index] != '-') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_mon = atoi(token) - 1;
  if (token_index > 0) {
    success++; //assume 'month' was successfully read.
    index++;
  }

  //go to 'T' character.
  token_index = 0;
  while (index < len && timevalue[index] != 'T') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_mday = atoi(token);
  if (token_index > 0) {
    success++; //assume 'day' was successfully read.
    index++;
  }

  //go to ':' character.
  token_index = 0;
  while (index < len && timevalue[index] != ':') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_hour = atoi(token);
  if (token_index > 0) {
    success++; //assume 'hour' was successfully read.
    index++;
  }

  //go to ':' character.
  token_index = 0;
  while (index < len && timevalue[index] != ':') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_min = atoi(token);
  if (token_index > 0) {
    success++; //assume 'minutes' was successfully read.
    index++;
  }

  //go to '+' or '-' character.
  token_index = 0;
  while (index < len && timevalue[index] != '+' && timevalue[index] != '-') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_sec = atof(token);
  if (token_index > 0) {
    success++; //assume 'seconds' was successfully read.
    if (timevalue[index] == '+') {
      index++;
    }
  }

  //go to ':' character.
  token_index = 0;
  while (index < len && timevalue[index] != ':') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  offset_hours = atoi(token);
  if (token_index > 0) {
    success++; //assume gmt offset hours was successfully read.
    index++;
  }

  //go to end.
  token_index = 0;
  while (index < len) {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  offset_min = atoi(token);
  if (token_index > 0) {
    success++; //assume gmt offset minutes was successfully read.
    index++;
  }
  time->tm_gmtoff = ((offset_hours * 60) + offset_min) * 60;

  free(timevalue);
  return time;
}

/**
 * Write a dateTime value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsDateTimeType(xmlTextWriterPtr writer, struct tm *value) {
  return xmlTextWriterWriteFormatString(writer, "%04i-%02i-%02iT%02i:%02i:%02i.000%+03i:%02i", value->tm_year + 1900, value->tm_mon + 1, value->tm_mday, value->tm_hour, value->tm_min, value->tm_sec, (int) (value->tm_gmtoff / 3600), (int) ((value->tm_gmtoff / 60) % 60));
}

/**
 * Frees a dateTime type from memory.
 *
 * @param value The value to free.
 */
static void freeXsDateTimeType(struct tm *value) {
  //no-op
}

/*******************xs:time************************************/

/**
 * Read a time value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the time.
 */
static struct tm *xmlTextReaderReadXsTimeType(xmlTextReaderPtr reader) {
  struct tm * time = calloc(1, sizeof(struct tm));
  xmlChar *timevalue = xmlTextReaderReadEntireNodeValue(reader);
  int success = 0, index = 0, token_index = 0, len = xmlStrlen(timevalue), offset_hours = 0, offset_min = 0;
  char token[len];

  //date time format: hh:MM:ss+oo:oo
  //go to ':' character.
  token_index = 0;
  while (index < len && timevalue[index] != ':') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_hour = atoi(token);
  if (token_index > 0) {
    success++; //assume 'hour' was successfully read.
    index++;
  }

  //go to ':' character.
  token_index = 0;
  while (index < len && timevalue[index] != ':') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_min = atoi(token);
  if (token_index > 0) {
    success++; //assume 'minutes' was successfully read.
    index++;
  }

  //go to '+' or '-' character.
  token_index = 0;
  while (index < len && timevalue[index] != '+' && timevalue[index] != '-') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_sec = atof(token);
  if (token_index > 0) {
    success++; //assume 'seconds' was successfully read.
    if (timevalue[index] == '+') {
      index++;
    }
  }

  //go to ':' character.
  token_index = 0;
  while (index < len && timevalue[index] != ':') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  offset_hours = atoi(token);
  if (token_index > 0) {
    success++; //assume gmt offset hours was successfully read.
    index++;
  }

  //go to end.
  token_index = 0;
  while (index < len) {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  offset_min = atoi(token);
  if (token_index > 0) {
    success++; //assume gmt offset minutes was successfully read.
    index++;
  }
  time->tm_gmtoff = ((offset_hours * 60) + offset_min) * 60;

  free(timevalue);
  return time;
}

/**
 * Write a time value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsTimeType(xmlTextWriterPtr writer, struct tm *value) {
  return xmlTextWriterWriteFormatString(writer, "%02i:%02i:%02i.000%+03i:%02i", value->tm_hour, value->tm_min, value->tm_sec, (int) (value->tm_gmtoff / 3600), (int) ((value->tm_gmtoff / 60) % 60));
}

/**
 * Frees a time type from memory.
 *
 * @param value The value to free.
 */
static void freeXsTimeType(struct tm *value) {
  //no-op
}

/*******************xs:date************************************/

/**
 * Read a date value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the date.
 */
static struct tm *xmlTextReaderReadXsDateType(xmlTextReaderPtr reader) {
  struct tm * time = calloc(1, sizeof(struct tm));
  xmlChar *timevalue = xmlTextReaderReadEntireNodeValue(reader);
  int success = 0, index = 0, token_index = 0, len = xmlStrlen(timevalue), offset_hours = 0, offset_min = 0;
  char token[len];

  //date time format: yyyy-mm-dd+oo:oo
  //go to first '-' character.
  token_index = 0;
  while (index < len && timevalue[index] != '-') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_year = atoi(token) - 1900;
  if (token_index > 0) {
    success++; //assume 'year' was successfully read.
    index++;
  }

  //go to next '-' character.
  token_index = 0;
  while (index < len && timevalue[index] != '-') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_mon = atoi(token) - 1;
  if (token_index > 0) {
    success++; //assume 'month' was successfully read.
    index++;
  }

  //go to '+' or '-' character.
  token_index = 0;
  while (index < len && timevalue[index] != '+' && timevalue[index] != '-') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  time->tm_sec = atof(token);
  if (token_index > 0) {
    success++; //assume 'seconds' was successfully read.
    if (timevalue[index] == '+') {
      index++;
    }
  }

  //go to ':' character.
  token_index = 0;
  while (index < len && timevalue[index] != ':') {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  offset_hours = atoi(token);
  if (token_index > 0) {
    success++; //assume gmt offset hours was successfully read.
    index++;
  }

  //go to end.
  token_index = 0;
  while (index < len) {
    token[token_index++] = timevalue[index++];
  }
  token[token_index] = '\n';
  offset_min = atoi(token);
  if (token_index > 0) {
    success++; //assume gmt offset minutes was successfully read.
    index++;
  }
  time->tm_gmtoff = ((offset_hours * 60) + offset_min) * 60;

  free(timevalue);
  return time;
}

/**
 * Write a date value to the writer.
 *
 * @param writer The writer.
 * @param value The value to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsDateType(xmlTextWriterPtr writer, struct tm *value) {
  return xmlTextWriterWriteFormatString(writer, "%04i-%02i-%02i%+03i:%02i", value->tm_year + 1900, value->tm_mon + 1, value->tm_mday, (int) (value->tm_gmtoff / 3600), (int) ((value->tm_gmtoff / 60) % 60));
}

/**
 * Frees a date type from memory.
 *
 * @param value The value to free.
 */
static void freeXsDateType(struct tm *value) {
  //no-op
}

/*******************xs:anyType************************************/

/**
 * Frees a anyType type from memory.
 *
 * @param node The node to free.
 */
static void freeXsAnyTypeType(struct xmlBasicNode *node) {
  if (node->attributes != NULL) {
    freeXsAnyTypeType(node->attributes);
  }
  if (node->value != NULL) {
    free(node->value);
  }
  if (node->child_elements != NULL) {
    freeXsAnyTypeType(node->child_elements);
  }
  if (node->name != NULL) {
    free(node->name);
  }
  if (node->prefix != NULL) {
    free(node->prefix);
  }
  if (node->ns != NULL) {
    free(node->ns);
  }
  if (node->sibling != NULL) {
    freeXsAnyTypeType(node->sibling);
    free(node->sibling);
  }
}

/**
 * Read a anyType value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the anyType., or NULL if error.
 */
static struct xmlBasicNode *xmlTextReaderReadXsAnyTypeType(xmlTextReaderPtr reader) {
  struct xmlBasicNode *child, *next, *node = calloc(1, sizeof(struct xmlBasicNode));
  int status, depth = xmlTextReaderDepth(reader);
  const xmlChar *text;

  node->name = xmlTextReaderLocalName(reader);
  node->ns = xmlTextReaderNamespaceUri(reader);
  node->prefix = xmlTextReaderPrefix(reader);

  if (xmlTextReaderHasAttributes(reader)) {
    child = NULL;
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      next = calloc(1, sizeof(struct xmlBasicNode));
      if (child == NULL) {
        node->attributes = next;
      }
      else {
        child->sibling = next;
      }
      child = next;
      child->name = xmlTextReaderLocalName(reader);
      child->ns = xmlTextReaderNamespaceUri(reader);
      child->prefix = xmlTextReaderPrefix(reader);
      child->value = xmlTextReaderValue(reader);
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
      freeXsAnyTypeType(node);
      free(node);
      return NULL;
    }
  }

  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    status = xmlTextReaderRead(reader);
    while (status == 1 && xmlTextReaderDepth(reader) > depth) {
      switch (xmlTextReaderNodeType(reader)) {
        case XML_READER_TYPE_ELEMENT:
          child = xmlTextReaderReadXsAnyTypeType(reader);
          if (child == NULL) {
            //panic: xml read error
            freeXsAnyTypeType(node);
            free(node);
            return NULL;
          }

          next = node->child_elements;
          if (next == NULL) {
            node->child_elements = child;
          }
          else {
            while (1) {
              if (next->sibling == NULL) {
                next->sibling = child;
                break;
              }
              next = next->sibling;
            }
          }

          break;
        case XML_READER_TYPE_TEXT:
        case XML_READER_TYPE_CDATA:
          text = xmlTextReaderConstValue(reader);
          node->value = xmlStrncat(node->value, text, xmlStrlen(text));
          break;
        default:
          //skip anything else.
          break;
      }

      status = xmlTextReaderRead(reader);
    }

    if (status < 1) {
      //panic: xml read error
      freeXsAnyTypeType(node);
      free(node);
      return NULL;
    }
  }

  return node;
}

/**
 * Write a anyType value to the writer.
 *
 * @param writer The writer.
 * @param node The node to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsAnyTypeType(xmlTextWriterPtr writer, struct xmlBasicNode *node) {
  int status;
  int totalBytes = 0;
  struct xmlBasicNode *next;

  status = xmlTextWriterStartElementNS(writer, node->prefix, node->name, node->ns);
  if (status < 0) {
    return status;
  }
  totalBytes += status;

  next = node->attributes;
  while (next != NULL) {
    status = xmlTextWriterWriteAttributeNS(writer, next->prefix, next->name, next->ns, next->value);
    if (status < 0) {
      return status;
    }
    totalBytes += status;
    next = next->sibling;
  }

  if (node->value != NULL) {
    status = xmlTextWriterWriteString(writer, node->value);
    if (status < 0) {
      //panic: xml write error
      return status;
    }
    totalBytes += status;
  }

  next = node->child_elements;
  while (next != NULL) {
    status = xmlTextWriterWriteXsAnyTypeType(writer, next);
    if (status < 0) {
      return status;
    }
    totalBytes += status;
    next = next->sibling;
  }

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Read a anyType element value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the anyType., or NULL if error.
 */
static struct xmlBasicNode *xmlTextReaderReadXsAnyTypeElement(xmlTextReaderPtr reader) {
  return xmlTextReaderReadXsAnyTypeType(reader);
}

/**
 * Write a anyType element value to the writer.
 *
 * @param writer The writer.
 * @param node The node to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsAnyTypeElement(xmlTextWriterPtr writer, struct xmlBasicNode *node) {
  return xmlTextWriterWriteXsAnyTypeType(writer, node);
}

/**
 * Write a anyType element value to the writer.
 *
 * @param writer The writer.
 * @param node The node to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsAnyTypeElementNS(xmlTextWriterPtr writer, struct xmlBasicNode *node, int writeNamespaces) {
  return xmlTextWriterWriteXsAnyTypeType(writer, node);
}

/**
 * Free a anyType element value.
 *
 * @param node The node.
 */
static void freeXsAnyTypeElement(struct xmlBasicNode *node) {
  freeXsAnyTypeType(node);
}

/*******************xs:anySimpleType************************************/

/**
 * Frees a anyType type from memory.
 *
 * @param node The node to free.
 */
static void freeXsAnySimpleTypeType(struct xmlBasicNode *node) {
  freeXsAnyTypeType(node);
}

/**
 * Read a anyType value from the reader.
 *
 * @param reader The reader (pointing at a node with a value).
 * @return pointer to the anyType., or NULL if error.
 */
static struct xmlBasicNode *xmlTextReaderReadXsAnySimpleTypeType(xmlTextReaderPtr reader) {
  struct xmlBasicNode *node = calloc(1, sizeof(struct xmlBasicNode));

  node->name = xmlTextReaderLocalName(reader);
  node->ns = xmlTextReaderNamespaceUri(reader);
  node->prefix = xmlTextReaderPrefix(reader);
  node->value = xmlTextReaderReadEntireNodeValue(reader);

  return node;
}

/**
 * Write a anyType value to the writer.
 *
 * @param writer The writer.
 * @param node The node to be written.
 * @return the bytes written (may be 0 because of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteXsAnySimpleTypeType(xmlTextWriterPtr writer, struct xmlBasicNode *node) {
  if (node->value != NULL) {
    return xmlTextWriterWriteXsStringType(writer, node->value);
  }

  return 0;
}

#endif /* BASIC_XML_FUNCTIONS_Xs */

#ifndef DEF_Grisu_dto_mountPoint_H
#define DEF_Grisu_dto_mountPoint_H

/**
 *  The concept of MountPoints is pretty important within grisu. A MountPoint is
 basically a mapping of a "logical name" to an url. Much like mountpoints in a
 unix filesystem. A logical name should contain the site where the filesystem
 sits and the VO that has got access to this filesystem so that the user can
 recognise which one is meant when looking at the name in a file browser.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_mountPoint {


  /**
   * (no documentation provided)
   */
  xmlChar *rootUrl;

  /**
   * (no documentation provided)
   */
  xmlChar *alias;

  /**
   * (no documentation provided)
   */
  xmlChar *dn;

  /**
   * the fqan
   */
  xmlChar *fqan;

  /**
   * (no documentation provided)
   */
  xmlChar *site;

  /**
   * (no documentation provided)
   */
  int automaticallyMounted;

  /**
   * (no documentation provided)
   */
  int disabled;
};

/**
 * Reads a MountPoint element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}mountpoint", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The MountPoint, or NULL in case of error.
 */
struct Grisu_dto_mountPoint *xml_read_Grisu_dto_mountPoint(xmlTextReaderPtr reader);

/**
 * Writes a MountPoint to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoint".
 *
 * @param writer The XML writer.
 * @param _mountPoint The MountPoint to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_mountPoint(xmlTextWriterPtr writer, struct Grisu_dto_mountPoint *_mountPoint);

/**
 * Frees a MountPoint.
 *
 * @param _mountPoint The MountPoint to free.
 */
void free_Grisu_dto_mountPoint(struct Grisu_dto_mountPoint *_mountPoint);

/**
 * Reads a MountPoint element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}mountpoint", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The MountPoint, or NULL in case of error.
 */
struct Grisu_dto_mountPoint *xmlTextReaderReadDtoMountpointElement(xmlTextReaderPtr reader);

/**
 * Writes a MountPoint to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoint".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _mountPoint The MountPoint to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoMountpointElement(xmlTextWriterPtr writer, struct Grisu_dto_mountPoint *_mountPoint);

/**
 * Writes a MountPoint to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoint".
 *
 * @param writer The XML writer.
 * @param _mountPoint The MountPoint to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoMountpointElementNS(xmlTextWriterPtr writer, struct Grisu_dto_mountPoint *_mountPoint, int writeNamespaces);

/**
 * Frees the children of a MountPoint.
 *
 * @param _mountPoint The MountPoint whose children are to be free.
 */
static void freeDtoMountpointElement(struct Grisu_dto_mountPoint *_mountPoint);

/**
 * Reads a MountPoint from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The MountPoint, or NULL in case of error.
 */
static struct Grisu_dto_mountPoint *xmlTextReaderReadDtoMountPointType(xmlTextReaderPtr reader);

/**
 * Writes a MountPoint to XML.
 *
 * @param writer The XML writer.
 * @param _mountPoint The MountPoint to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoMountPointType(xmlTextWriterPtr writer, struct Grisu_dto_mountPoint *_mountPoint);

/**
 * Frees the elements of a MountPoint.
 *
 * @param _mountPoint The MountPoint to free.
 */
static void freeDtoMountPointType(struct Grisu_dto_mountPoint *_mountPoint);

#endif /* DEF_Grisu_dto_mountPoint_H */
#ifndef DEF_Grisu_dto_dtoActionStatus_H
#define DEF_Grisu_dto_dtoActionStatus_H

/**
 * (no documentation provided)
 */
struct Grisu_dto_dtoActionStatus {


  /**
   * (no documentation provided)
   */
  xmlChar *handle;

  /**
   * (no documentation provided)
   */
  struct tm *lastUpdate;

  /**
   * (no documentation provided)
   */
  int failed;

  /**
   * (no documentation provided)
   */
  int totalElements;

  /**
   * (no documentation provided)
   */
  int finished;

  /**
   * (no documentation provided)
   */
  int currentElements;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoLogItem *log;

  /**
   * Size of the log array.
   */
  int _sizeof_log;
};

/**
 * Reads a DtoActionStatus element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}actionStatus", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoActionStatus, or NULL in case of error.
 */
struct Grisu_dto_dtoActionStatus *xml_read_Grisu_dto_dtoActionStatus(xmlTextReaderPtr reader);

/**
 * Writes a DtoActionStatus to XML under element name "{http://api.grisu.arcs.org.au/dto}actionStatus".
 *
 * @param writer The XML writer.
 * @param _dtoActionStatus The DtoActionStatus to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoActionStatus(xmlTextWriterPtr writer, struct Grisu_dto_dtoActionStatus *_dtoActionStatus);

/**
 * Frees a DtoActionStatus.
 *
 * @param _dtoActionStatus The DtoActionStatus to free.
 */
void free_Grisu_dto_dtoActionStatus(struct Grisu_dto_dtoActionStatus *_dtoActionStatus);

/**
 * Reads a DtoActionStatus element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}actionStatus", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoActionStatus, or NULL in case of error.
 */
struct Grisu_dto_dtoActionStatus *xmlTextReaderReadDtoActionStatusElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoActionStatus to XML under element name "{http://api.grisu.arcs.org.au/dto}actionStatus".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoActionStatus The DtoActionStatus to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoActionStatusElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoActionStatus *_dtoActionStatus);

/**
 * Writes a DtoActionStatus to XML under element name "{http://api.grisu.arcs.org.au/dto}actionStatus".
 *
 * @param writer The XML writer.
 * @param _dtoActionStatus The DtoActionStatus to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoActionStatusElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoActionStatus *_dtoActionStatus, int writeNamespaces);

/**
 * Frees the children of a DtoActionStatus.
 *
 * @param _dtoActionStatus The DtoActionStatus whose children are to be free.
 */
static void freeDtoActionStatusElement(struct Grisu_dto_dtoActionStatus *_dtoActionStatus);

/**
 * Reads a DtoActionStatus from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoActionStatus, or NULL in case of error.
 */
static struct Grisu_dto_dtoActionStatus *xmlTextReaderReadDtoDtoActionStatusType(xmlTextReaderPtr reader);

/**
 * Writes a DtoActionStatus to XML.
 *
 * @param writer The XML writer.
 * @param _dtoActionStatus The DtoActionStatus to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoActionStatusType(xmlTextWriterPtr writer, struct Grisu_dto_dtoActionStatus *_dtoActionStatus);

/**
 * Frees the elements of a DtoActionStatus.
 *
 * @param _dtoActionStatus The DtoActionStatus to free.
 */
static void freeDtoDtoActionStatusType(struct Grisu_dto_dtoActionStatus *_dtoActionStatus);

#endif /* DEF_Grisu_dto_dtoActionStatus_H */
#ifndef DEF_Grisu_dto_dtoApplicationDetail_H
#define DEF_Grisu_dto_dtoApplicationDetail_H

/**
 *  Just a wrapper that contains a key/value pair to represent one application
 detail.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoApplicationDetail {


  /**
   * (no documentation provided)
   */
  xmlChar *key;

  /**
   * (no documentation provided)
   */
  xmlChar *value;
};

/**
 * Reads a DtoApplicationDetail element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}applicationdetail", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoApplicationDetail, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationDetail *xml_read_Grisu_dto_dtoApplicationDetail(xmlTextReaderPtr reader);

/**
 * Writes a DtoApplicationDetail to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetail".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetail The DtoApplicationDetail to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoApplicationDetail(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail);

/**
 * Frees a DtoApplicationDetail.
 *
 * @param _dtoApplicationDetail The DtoApplicationDetail to free.
 */
void free_Grisu_dto_dtoApplicationDetail(struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail);

/**
 * Reads a DtoApplicationDetail element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}applicationdetail", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoApplicationDetail, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationDetail *xmlTextReaderReadDtoApplicationdetailElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoApplicationDetail to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetail".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetail The DtoApplicationDetail to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoApplicationdetailElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail);

/**
 * Writes a DtoApplicationDetail to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetail".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetail The DtoApplicationDetail to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoApplicationdetailElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail, int writeNamespaces);

/**
 * Frees the children of a DtoApplicationDetail.
 *
 * @param _dtoApplicationDetail The DtoApplicationDetail whose children are to be free.
 */
static void freeDtoApplicationdetailElement(struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail);

/**
 * Reads a DtoApplicationDetail from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoApplicationDetail, or NULL in case of error.
 */
static struct Grisu_dto_dtoApplicationDetail *xmlTextReaderReadDtoDtoApplicationDetailType(xmlTextReaderPtr reader);

/**
 * Writes a DtoApplicationDetail to XML.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetail The DtoApplicationDetail to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoApplicationDetailType(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail);

/**
 * Frees the elements of a DtoApplicationDetail.
 *
 * @param _dtoApplicationDetail The DtoApplicationDetail to free.
 */
static void freeDtoDtoApplicationDetailType(struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail);

#endif /* DEF_Grisu_dto_dtoApplicationDetail_H */
#ifndef DEF_Grisu_dto_dtoApplicationDetails_H
#define DEF_Grisu_dto_dtoApplicationDetails_H

/**
 *  A wrapper that contains a list of {@link DtoApplicationDetail} objects.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoApplicationDetails {


  /**
   * (no documentation provided)
   */
  xmlChar *applicationName;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoApplicationDetail *details;

  /**
   * Size of the details array.
   */
  int _sizeof_details;
};

/**
 * Reads a DtoApplicationDetails element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}applicationdetails", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoApplicationDetails, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationDetails *xml_read_Grisu_dto_dtoApplicationDetails(xmlTextReaderPtr reader);

/**
 * Writes a DtoApplicationDetails to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetails".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetails The DtoApplicationDetails to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoApplicationDetails(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails);

/**
 * Frees a DtoApplicationDetails.
 *
 * @param _dtoApplicationDetails The DtoApplicationDetails to free.
 */
void free_Grisu_dto_dtoApplicationDetails(struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails);

/**
 * Reads a DtoApplicationDetails element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}applicationdetails", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoApplicationDetails, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationDetails *xmlTextReaderReadDtoApplicationdetailsElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoApplicationDetails to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetails".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetails The DtoApplicationDetails to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoApplicationdetailsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails);

/**
 * Writes a DtoApplicationDetails to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetails".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetails The DtoApplicationDetails to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoApplicationdetailsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails, int writeNamespaces);

/**
 * Frees the children of a DtoApplicationDetails.
 *
 * @param _dtoApplicationDetails The DtoApplicationDetails whose children are to be free.
 */
static void freeDtoApplicationdetailsElement(struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails);

/**
 * Reads a DtoApplicationDetails from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoApplicationDetails, or NULL in case of error.
 */
static struct Grisu_dto_dtoApplicationDetails *xmlTextReaderReadDtoDtoApplicationDetailsType(xmlTextReaderPtr reader);

/**
 * Writes a DtoApplicationDetails to XML.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetails The DtoApplicationDetails to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoApplicationDetailsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails);

/**
 * Frees the elements of a DtoApplicationDetails.
 *
 * @param _dtoApplicationDetails The DtoApplicationDetails to free.
 */
static void freeDtoDtoApplicationDetailsType(struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails);

#endif /* DEF_Grisu_dto_dtoApplicationDetails_H */
#ifndef DEF_Grisu_dto_dtoApplicationInfo_H
#define DEF_Grisu_dto_dtoApplicationInfo_H

/**
 *  A class that contains information about which submission locations are
 available for a certain application, sorted by version.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoApplicationInfo {


  /**
   * (no documentation provided)
   */
  xmlChar *name;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoVersionInfo *allVersions;

  /**
   * Size of the allVersions array.
   */
  int _sizeof_allVersions;
};

/**
 * Reads a DtoApplicationInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}application", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoApplicationInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationInfo *xml_read_Grisu_dto_dtoApplicationInfo(xmlTextReaderPtr reader);

/**
 * Writes a DtoApplicationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}application".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationInfo The DtoApplicationInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoApplicationInfo(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo);

/**
 * Frees a DtoApplicationInfo.
 *
 * @param _dtoApplicationInfo The DtoApplicationInfo to free.
 */
void free_Grisu_dto_dtoApplicationInfo(struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo);

/**
 * Reads a DtoApplicationInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}application", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoApplicationInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationInfo *xmlTextReaderReadDtoApplicationElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoApplicationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}application".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationInfo The DtoApplicationInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoApplicationElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo);

/**
 * Writes a DtoApplicationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}application".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationInfo The DtoApplicationInfo to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoApplicationElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo, int writeNamespaces);

/**
 * Frees the children of a DtoApplicationInfo.
 *
 * @param _dtoApplicationInfo The DtoApplicationInfo whose children are to be free.
 */
static void freeDtoApplicationElement(struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo);

/**
 * Reads a DtoApplicationInfo from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoApplicationInfo, or NULL in case of error.
 */
static struct Grisu_dto_dtoApplicationInfo *xmlTextReaderReadDtoDtoApplicationInfoType(xmlTextReaderPtr reader);

/**
 * Writes a DtoApplicationInfo to XML.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationInfo The DtoApplicationInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoApplicationInfoType(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo);

/**
 * Frees the elements of a DtoApplicationInfo.
 *
 * @param _dtoApplicationInfo The DtoApplicationInfo to free.
 */
static void freeDtoDtoApplicationInfoType(struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo);

#endif /* DEF_Grisu_dto_dtoApplicationInfo_H */
#ifndef DEF_Grisu_dto_dtoBatchJob_H
#define DEF_Grisu_dto_dtoBatchJob_H

/**
 * (no documentation provided)
 */
struct Grisu_dto_dtoBatchJob {


  /**
   * (no documentation provided)
   */
  int finished;

  /**
   * (no documentation provided)
   */
  xmlChar *batchJobname;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoJobs *failedJobs;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoJobs *jobs;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoLogMessages *messages;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoJobProperty *properties;

  /**
   * Size of the properties array.
   */
  int _sizeof_properties;

  /**
   * (no documentation provided)
   */
  int status;

  /**
   * (no documentation provided)
   */
  xmlChar *submissionFqan;
};

/**
 * Reads a DtoBatchJob element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}multiPartJob", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoBatchJob, or NULL in case of error.
 */
struct Grisu_dto_dtoBatchJob *xml_read_Grisu_dto_dtoBatchJob(xmlTextReaderPtr reader);

/**
 * Writes a DtoBatchJob to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJob".
 *
 * @param writer The XML writer.
 * @param _dtoBatchJob The DtoBatchJob to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoBatchJob(xmlTextWriterPtr writer, struct Grisu_dto_dtoBatchJob *_dtoBatchJob);

/**
 * Frees a DtoBatchJob.
 *
 * @param _dtoBatchJob The DtoBatchJob to free.
 */
void free_Grisu_dto_dtoBatchJob(struct Grisu_dto_dtoBatchJob *_dtoBatchJob);

/**
 * Reads a DtoBatchJob element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}multiPartJob", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoBatchJob, or NULL in case of error.
 */
struct Grisu_dto_dtoBatchJob *xmlTextReaderReadDtoMultiPartJobElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoBatchJob to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJob".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoBatchJob The DtoBatchJob to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoMultiPartJobElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoBatchJob *_dtoBatchJob);

/**
 * Writes a DtoBatchJob to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJob".
 *
 * @param writer The XML writer.
 * @param _dtoBatchJob The DtoBatchJob to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoMultiPartJobElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoBatchJob *_dtoBatchJob, int writeNamespaces);

/**
 * Frees the children of a DtoBatchJob.
 *
 * @param _dtoBatchJob The DtoBatchJob whose children are to be free.
 */
static void freeDtoMultiPartJobElement(struct Grisu_dto_dtoBatchJob *_dtoBatchJob);

/**
 * Reads a DtoBatchJob from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoBatchJob, or NULL in case of error.
 */
static struct Grisu_dto_dtoBatchJob *xmlTextReaderReadDtoDtoBatchJobType(xmlTextReaderPtr reader);

/**
 * Writes a DtoBatchJob to XML.
 *
 * @param writer The XML writer.
 * @param _dtoBatchJob The DtoBatchJob to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoBatchJobType(xmlTextWriterPtr writer, struct Grisu_dto_dtoBatchJob *_dtoBatchJob);

/**
 * Frees the elements of a DtoBatchJob.
 *
 * @param _dtoBatchJob The DtoBatchJob to free.
 */
static void freeDtoDtoBatchJobType(struct Grisu_dto_dtoBatchJob *_dtoBatchJob);

#endif /* DEF_Grisu_dto_dtoBatchJob_H */
#ifndef DEF_Grisu_dto_dtoDataLocation_H
#define DEF_Grisu_dto_dtoDataLocation_H

/**
 *  A wrapper that contains information about a datalocation.
 
 A datalocation contains a root url and a list of relative paths on top of
 this root url. Also the fqan that is used to access this datalocation.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoDataLocation {


  /**
   * (no documentation provided)
   */
  xmlChar *rooturl;

  /**
   * (no documentation provided)
   */
  xmlChar *fqan;

  /**
   * (no documentation provided)
   */
  xmlChar *paths;

  /**
   * Size of the paths array.
   */
  int _sizeof_paths;
};

/**
 * Reads a DtoDataLocation element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}datalocation", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoDataLocation, or NULL in case of error.
 */
struct Grisu_dto_dtoDataLocation *xml_read_Grisu_dto_dtoDataLocation(xmlTextReaderPtr reader);

/**
 * Writes a DtoDataLocation to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocation".
 *
 * @param writer The XML writer.
 * @param _dtoDataLocation The DtoDataLocation to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoDataLocation(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocation *_dtoDataLocation);

/**
 * Frees a DtoDataLocation.
 *
 * @param _dtoDataLocation The DtoDataLocation to free.
 */
void free_Grisu_dto_dtoDataLocation(struct Grisu_dto_dtoDataLocation *_dtoDataLocation);

/**
 * Reads a DtoDataLocation element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}datalocation", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoDataLocation, or NULL in case of error.
 */
struct Grisu_dto_dtoDataLocation *xmlTextReaderReadDtoDatalocationElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoDataLocation to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocation".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoDataLocation The DtoDataLocation to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDatalocationElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocation *_dtoDataLocation);

/**
 * Writes a DtoDataLocation to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocation".
 *
 * @param writer The XML writer.
 * @param _dtoDataLocation The DtoDataLocation to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDatalocationElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocation *_dtoDataLocation, int writeNamespaces);

/**
 * Frees the children of a DtoDataLocation.
 *
 * @param _dtoDataLocation The DtoDataLocation whose children are to be free.
 */
static void freeDtoDatalocationElement(struct Grisu_dto_dtoDataLocation *_dtoDataLocation);

/**
 * Reads a DtoDataLocation from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoDataLocation, or NULL in case of error.
 */
static struct Grisu_dto_dtoDataLocation *xmlTextReaderReadDtoDtoDataLocationType(xmlTextReaderPtr reader);

/**
 * Writes a DtoDataLocation to XML.
 *
 * @param writer The XML writer.
 * @param _dtoDataLocation The DtoDataLocation to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoDataLocationType(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocation *_dtoDataLocation);

/**
 * Frees the elements of a DtoDataLocation.
 *
 * @param _dtoDataLocation The DtoDataLocation to free.
 */
static void freeDtoDtoDataLocationType(struct Grisu_dto_dtoDataLocation *_dtoDataLocation);

#endif /* DEF_Grisu_dto_dtoDataLocation_H */
#ifndef DEF_Grisu_dto_dtoDataLocations_H
#define DEF_Grisu_dto_dtoDataLocations_H

/**
 *  A wrapper that contains a list of {@link DtoDataLocation} objects.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoDataLocations {


  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoDataLocation *dataLocations;

  /**
   * Size of the dataLocations array.
   */
  int _sizeof_dataLocations;
};

/**
 * Reads a DtoDataLocations element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}datalocations", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoDataLocations, or NULL in case of error.
 */
struct Grisu_dto_dtoDataLocations *xml_read_Grisu_dto_dtoDataLocations(xmlTextReaderPtr reader);

/**
 * Writes a DtoDataLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocations".
 *
 * @param writer The XML writer.
 * @param _dtoDataLocations The DtoDataLocations to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoDataLocations(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocations *_dtoDataLocations);

/**
 * Frees a DtoDataLocations.
 *
 * @param _dtoDataLocations The DtoDataLocations to free.
 */
void free_Grisu_dto_dtoDataLocations(struct Grisu_dto_dtoDataLocations *_dtoDataLocations);

/**
 * Reads a DtoDataLocations element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}datalocations", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoDataLocations, or NULL in case of error.
 */
struct Grisu_dto_dtoDataLocations *xmlTextReaderReadDtoDatalocationsElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoDataLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocations".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoDataLocations The DtoDataLocations to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDatalocationsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocations *_dtoDataLocations);

/**
 * Writes a DtoDataLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocations".
 *
 * @param writer The XML writer.
 * @param _dtoDataLocations The DtoDataLocations to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDatalocationsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocations *_dtoDataLocations, int writeNamespaces);

/**
 * Frees the children of a DtoDataLocations.
 *
 * @param _dtoDataLocations The DtoDataLocations whose children are to be free.
 */
static void freeDtoDatalocationsElement(struct Grisu_dto_dtoDataLocations *_dtoDataLocations);

/**
 * Reads a DtoDataLocations from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoDataLocations, or NULL in case of error.
 */
static struct Grisu_dto_dtoDataLocations *xmlTextReaderReadDtoDtoDataLocationsType(xmlTextReaderPtr reader);

/**
 * Writes a DtoDataLocations to XML.
 *
 * @param writer The XML writer.
 * @param _dtoDataLocations The DtoDataLocations to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoDataLocationsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocations *_dtoDataLocations);

/**
 * Frees the elements of a DtoDataLocations.
 *
 * @param _dtoDataLocations The DtoDataLocations to free.
 */
static void freeDtoDtoDataLocationsType(struct Grisu_dto_dtoDataLocations *_dtoDataLocations);

#endif /* DEF_Grisu_dto_dtoDataLocations_H */
#ifndef DEF_Grisu_dto_dtoFile_H
#define DEF_Grisu_dto_dtoFile_H

/**
 *  A wrapper that contains information about a remote file.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoFile {


  /**
   * (no documentation provided)
   */
  int folder;

  /**
   * (no documentation provided)
   */
  xmlChar *rootUrl;

  /**
   * (no documentation provided)
   */
  xmlChar *name;

  /**
   * (no documentation provided)
   */
  long lastModified;

  /**
   * (no documentation provided)
   */
  long size;
};

/**
 * Reads a DtoFile element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}file", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoFile, or NULL in case of error.
 */
struct Grisu_dto_dtoFile *xml_read_Grisu_dto_dtoFile(xmlTextReaderPtr reader);

/**
 * Writes a DtoFile to XML under element name "{http://api.grisu.arcs.org.au/dto}file".
 *
 * @param writer The XML writer.
 * @param _dtoFile The DtoFile to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoFile(xmlTextWriterPtr writer, struct Grisu_dto_dtoFile *_dtoFile);

/**
 * Frees a DtoFile.
 *
 * @param _dtoFile The DtoFile to free.
 */
void free_Grisu_dto_dtoFile(struct Grisu_dto_dtoFile *_dtoFile);

/**
 * Reads a DtoFile element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}file", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoFile, or NULL in case of error.
 */
struct Grisu_dto_dtoFile *xmlTextReaderReadDtoFileElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoFile to XML under element name "{http://api.grisu.arcs.org.au/dto}file".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoFile The DtoFile to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoFileElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoFile *_dtoFile);

/**
 * Writes a DtoFile to XML under element name "{http://api.grisu.arcs.org.au/dto}file".
 *
 * @param writer The XML writer.
 * @param _dtoFile The DtoFile to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoFileElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoFile *_dtoFile, int writeNamespaces);

/**
 * Frees the children of a DtoFile.
 *
 * @param _dtoFile The DtoFile whose children are to be free.
 */
static void freeDtoFileElement(struct Grisu_dto_dtoFile *_dtoFile);

/**
 * Reads a DtoFile from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoFile, or NULL in case of error.
 */
static struct Grisu_dto_dtoFile *xmlTextReaderReadDtoDtoFileType(xmlTextReaderPtr reader);

/**
 * Writes a DtoFile to XML.
 *
 * @param writer The XML writer.
 * @param _dtoFile The DtoFile to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoFileType(xmlTextWriterPtr writer, struct Grisu_dto_dtoFile *_dtoFile);

/**
 * Frees the elements of a DtoFile.
 *
 * @param _dtoFile The DtoFile to free.
 */
static void freeDtoDtoFileType(struct Grisu_dto_dtoFile *_dtoFile);

#endif /* DEF_Grisu_dto_dtoFile_H */
#ifndef DEF_Grisu_dto_dtoFolder_H
#define DEF_Grisu_dto_dtoFolder_H

/**
 *  A wrapper that contains information about one remote folder.
 
 It has the absolute url to this folder, the basename and two lists of
 children folders and children files.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoFolder {


  /**
   * (no documentation provided)
   */
  int folder;

  /**
   * (no documentation provided)
   */
  xmlChar *rootUrl;

  /**
   * (no documentation provided)
   */
  xmlChar *name;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoFile *childrenFiles;

  /**
   * Size of the childrenFiles array.
   */
  int _sizeof_childrenFiles;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoFolder *childrenFolders;

  /**
   * Size of the childrenFolders array.
   */
  int _sizeof_childrenFolders;
};

/**
 * Reads a DtoFolder element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}folder", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoFolder, or NULL in case of error.
 */
struct Grisu_dto_dtoFolder *xml_read_Grisu_dto_dtoFolder(xmlTextReaderPtr reader);

/**
 * Writes a DtoFolder to XML under element name "{http://api.grisu.arcs.org.au/dto}folder".
 *
 * @param writer The XML writer.
 * @param _dtoFolder The DtoFolder to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoFolder(xmlTextWriterPtr writer, struct Grisu_dto_dtoFolder *_dtoFolder);

/**
 * Frees a DtoFolder.
 *
 * @param _dtoFolder The DtoFolder to free.
 */
void free_Grisu_dto_dtoFolder(struct Grisu_dto_dtoFolder *_dtoFolder);

/**
 * Reads a DtoFolder element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}folder", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoFolder, or NULL in case of error.
 */
struct Grisu_dto_dtoFolder *xmlTextReaderReadDtoFolderElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoFolder to XML under element name "{http://api.grisu.arcs.org.au/dto}folder".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoFolder The DtoFolder to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoFolderElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoFolder *_dtoFolder);

/**
 * Writes a DtoFolder to XML under element name "{http://api.grisu.arcs.org.au/dto}folder".
 *
 * @param writer The XML writer.
 * @param _dtoFolder The DtoFolder to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoFolderElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoFolder *_dtoFolder, int writeNamespaces);

/**
 * Frees the children of a DtoFolder.
 *
 * @param _dtoFolder The DtoFolder whose children are to be free.
 */
static void freeDtoFolderElement(struct Grisu_dto_dtoFolder *_dtoFolder);

/**
 * Reads a DtoFolder from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoFolder, or NULL in case of error.
 */
static struct Grisu_dto_dtoFolder *xmlTextReaderReadDtoDtoFolderType(xmlTextReaderPtr reader);

/**
 * Writes a DtoFolder to XML.
 *
 * @param writer The XML writer.
 * @param _dtoFolder The DtoFolder to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoFolderType(xmlTextWriterPtr writer, struct Grisu_dto_dtoFolder *_dtoFolder);

/**
 * Frees the elements of a DtoFolder.
 *
 * @param _dtoFolder The DtoFolder to free.
 */
static void freeDtoDtoFolderType(struct Grisu_dto_dtoFolder *_dtoFolder);

#endif /* DEF_Grisu_dto_dtoFolder_H */
#ifndef DEF_Grisu_dto_dtoGridResource_H
#define DEF_Grisu_dto_dtoGridResource_H

/**
 *  A wrapper object that is created when the grid is queried for resources that
 are able to run a certain type of job.
 
 This contains a snapshot of values for a single grid resource that can be of
 importance when deciding where to run a job.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoGridResource {


  /**
   * (no documentation provided)
   */
  xmlChar *applicationName;

  /**
   * (no documentation provided)
   */
  double siteLatitude;

  /**
   * (no documentation provided)
   */
  int desiredSoftwareVersionInstalled;

  /**
   * (no documentation provided)
   */
  double siteLongitude;

  /**
   * (no documentation provided)
   */
  xmlChar *queueName;

  /**
   * (no documentation provided)
   */
  xmlChar *siteName;

  /**
   * (no documentation provided)
   */
  xmlChar *allExecutables;

  /**
   * Size of the allExecutables array.
   */
  int _sizeof_allExecutables;

  /**
   * (no documentation provided)
   */
  xmlChar *availableApplicationVersion;

  /**
   * Size of the availableApplicationVersion array.
   */
  int _sizeof_availableApplicationVersion;

  /**
   * (no documentation provided)
   */
  xmlChar *contactString;

  /**
   * (no documentation provided)
   */
  int freeJobSlots;

  /**
   * (no documentation provided)
   */
  xmlChar *jobManager;

  /**
   * (no documentation provided)
   */
  int mainMemoryRAMSize;

  /**
   * (no documentation provided)
   */
  int mainMemoryVirtualSize;

  /**
   * (no documentation provided)
   */
  int rank;

  /**
   * (no documentation provided)
   */
  int runningJobs;

  /**
   * (no documentation provided)
   */
  int smpSize;

  /**
   * (no documentation provided)
   */
  int totalJobs;

  /**
   * (no documentation provided)
   */
  int waitingJobs;
};

/**
 * Reads a DtoGridResource element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}gridresource", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoGridResource, or NULL in case of error.
 */
struct Grisu_dto_dtoGridResource *xml_read_Grisu_dto_dtoGridResource(xmlTextReaderPtr reader);

/**
 * Writes a DtoGridResource to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresource".
 *
 * @param writer The XML writer.
 * @param _dtoGridResource The DtoGridResource to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoGridResource(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResource *_dtoGridResource);

/**
 * Frees a DtoGridResource.
 *
 * @param _dtoGridResource The DtoGridResource to free.
 */
void free_Grisu_dto_dtoGridResource(struct Grisu_dto_dtoGridResource *_dtoGridResource);

/**
 * Reads a DtoGridResource element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}gridresource", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoGridResource, or NULL in case of error.
 */
struct Grisu_dto_dtoGridResource *xmlTextReaderReadDtoGridresourceElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoGridResource to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresource".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoGridResource The DtoGridResource to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoGridresourceElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResource *_dtoGridResource);

/**
 * Writes a DtoGridResource to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresource".
 *
 * @param writer The XML writer.
 * @param _dtoGridResource The DtoGridResource to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoGridresourceElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResource *_dtoGridResource, int writeNamespaces);

/**
 * Frees the children of a DtoGridResource.
 *
 * @param _dtoGridResource The DtoGridResource whose children are to be free.
 */
static void freeDtoGridresourceElement(struct Grisu_dto_dtoGridResource *_dtoGridResource);

/**
 * Reads a DtoGridResource from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoGridResource, or NULL in case of error.
 */
static struct Grisu_dto_dtoGridResource *xmlTextReaderReadDtoDtoGridResourceType(xmlTextReaderPtr reader);

/**
 * Writes a DtoGridResource to XML.
 *
 * @param writer The XML writer.
 * @param _dtoGridResource The DtoGridResource to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoGridResourceType(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResource *_dtoGridResource);

/**
 * Frees the elements of a DtoGridResource.
 *
 * @param _dtoGridResource The DtoGridResource to free.
 */
static void freeDtoDtoGridResourceType(struct Grisu_dto_dtoGridResource *_dtoGridResource);

#endif /* DEF_Grisu_dto_dtoGridResource_H */
#ifndef DEF_Grisu_dto_dtoGridResources_H
#define DEF_Grisu_dto_dtoGridResources_H

/**
 *  A wrapper that holds a list of {@link DtoGridResource} objects.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoGridResources {


  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoGridResource *gridResources;

  /**
   * Size of the gridResources array.
   */
  int _sizeof_gridResources;
};

/**
 * Reads a DtoGridResources element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}gridresources", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoGridResources, or NULL in case of error.
 */
struct Grisu_dto_dtoGridResources *xml_read_Grisu_dto_dtoGridResources(xmlTextReaderPtr reader);

/**
 * Writes a DtoGridResources to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresources".
 *
 * @param writer The XML writer.
 * @param _dtoGridResources The DtoGridResources to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoGridResources(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResources *_dtoGridResources);

/**
 * Frees a DtoGridResources.
 *
 * @param _dtoGridResources The DtoGridResources to free.
 */
void free_Grisu_dto_dtoGridResources(struct Grisu_dto_dtoGridResources *_dtoGridResources);

/**
 * Reads a DtoGridResources element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}gridresources", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoGridResources, or NULL in case of error.
 */
struct Grisu_dto_dtoGridResources *xmlTextReaderReadDtoGridresourcesElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoGridResources to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresources".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoGridResources The DtoGridResources to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoGridresourcesElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResources *_dtoGridResources);

/**
 * Writes a DtoGridResources to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresources".
 *
 * @param writer The XML writer.
 * @param _dtoGridResources The DtoGridResources to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoGridresourcesElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResources *_dtoGridResources, int writeNamespaces);

/**
 * Frees the children of a DtoGridResources.
 *
 * @param _dtoGridResources The DtoGridResources whose children are to be free.
 */
static void freeDtoGridresourcesElement(struct Grisu_dto_dtoGridResources *_dtoGridResources);

/**
 * Reads a DtoGridResources from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoGridResources, or NULL in case of error.
 */
static struct Grisu_dto_dtoGridResources *xmlTextReaderReadDtoDtoGridResourcesType(xmlTextReaderPtr reader);

/**
 * Writes a DtoGridResources to XML.
 *
 * @param writer The XML writer.
 * @param _dtoGridResources The DtoGridResources to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoGridResourcesType(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResources *_dtoGridResources);

/**
 * Frees the elements of a DtoGridResources.
 *
 * @param _dtoGridResources The DtoGridResources to free.
 */
static void freeDtoDtoGridResourcesType(struct Grisu_dto_dtoGridResources *_dtoGridResources);

#endif /* DEF_Grisu_dto_dtoGridResources_H */
#ifndef DEF_Grisu_dto_dtoHost_H
#define DEF_Grisu_dto_dtoHost_H

/**
 *  A wrapper object that contains a hostname and the site to which this hostname
 belongs.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoHost {


  /**
   * (no documentation provided)
   */
  xmlChar *hostNameString;

  /**
   * (no documentation provided)
   */
  xmlChar *siteNameString;
};

/**
 * Reads a DtoHost element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}host", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoHost, or NULL in case of error.
 */
struct Grisu_dto_dtoHost *xml_read_Grisu_dto_dtoHost(xmlTextReaderPtr reader);

/**
 * Writes a DtoHost to XML under element name "{http://api.grisu.arcs.org.au/dto}host".
 *
 * @param writer The XML writer.
 * @param _dtoHost The DtoHost to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoHost(xmlTextWriterPtr writer, struct Grisu_dto_dtoHost *_dtoHost);

/**
 * Frees a DtoHost.
 *
 * @param _dtoHost The DtoHost to free.
 */
void free_Grisu_dto_dtoHost(struct Grisu_dto_dtoHost *_dtoHost);

/**
 * Reads a DtoHost element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}host", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoHost, or NULL in case of error.
 */
struct Grisu_dto_dtoHost *xmlTextReaderReadDtoHostElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoHost to XML under element name "{http://api.grisu.arcs.org.au/dto}host".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoHost The DtoHost to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoHostElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoHost *_dtoHost);

/**
 * Writes a DtoHost to XML under element name "{http://api.grisu.arcs.org.au/dto}host".
 *
 * @param writer The XML writer.
 * @param _dtoHost The DtoHost to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoHostElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoHost *_dtoHost, int writeNamespaces);

/**
 * Frees the children of a DtoHost.
 *
 * @param _dtoHost The DtoHost whose children are to be free.
 */
static void freeDtoHostElement(struct Grisu_dto_dtoHost *_dtoHost);

/**
 * Reads a DtoHost from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoHost, or NULL in case of error.
 */
static struct Grisu_dto_dtoHost *xmlTextReaderReadDtoDtoHostType(xmlTextReaderPtr reader);

/**
 * Writes a DtoHost to XML.
 *
 * @param writer The XML writer.
 * @param _dtoHost The DtoHost to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoHostType(xmlTextWriterPtr writer, struct Grisu_dto_dtoHost *_dtoHost);

/**
 * Frees the elements of a DtoHost.
 *
 * @param _dtoHost The DtoHost to free.
 */
static void freeDtoDtoHostType(struct Grisu_dto_dtoHost *_dtoHost);

#endif /* DEF_Grisu_dto_dtoHost_H */
#ifndef DEF_Grisu_dto_dtoHostsInfo_H
#define DEF_Grisu_dto_dtoHostsInfo_H

/**
 *  A map object that contains all hostnames gridwide. These hostnames are all
 mapped to the name of the site where they are located.
 
 This can be useful for displaying structured information about the grid to
 the user.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoHostsInfo {


  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoHost *allHosts;

  /**
   * Size of the allHosts array.
   */
  int _sizeof_allHosts;
};

/**
 * Reads a DtoHostsInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}hostsinfo", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoHostsInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoHostsInfo *xml_read_Grisu_dto_dtoHostsInfo(xmlTextReaderPtr reader);

/**
 * Writes a DtoHostsInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}hostsinfo".
 *
 * @param writer The XML writer.
 * @param _dtoHostsInfo The DtoHostsInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoHostsInfo(xmlTextWriterPtr writer, struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo);

/**
 * Frees a DtoHostsInfo.
 *
 * @param _dtoHostsInfo The DtoHostsInfo to free.
 */
void free_Grisu_dto_dtoHostsInfo(struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo);

/**
 * Reads a DtoHostsInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}hostsinfo", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoHostsInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoHostsInfo *xmlTextReaderReadDtoHostsinfoElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoHostsInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}hostsinfo".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoHostsInfo The DtoHostsInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoHostsinfoElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo);

/**
 * Writes a DtoHostsInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}hostsinfo".
 *
 * @param writer The XML writer.
 * @param _dtoHostsInfo The DtoHostsInfo to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoHostsinfoElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo, int writeNamespaces);

/**
 * Frees the children of a DtoHostsInfo.
 *
 * @param _dtoHostsInfo The DtoHostsInfo whose children are to be free.
 */
static void freeDtoHostsinfoElement(struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo);

/**
 * Reads a DtoHostsInfo from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoHostsInfo, or NULL in case of error.
 */
static struct Grisu_dto_dtoHostsInfo *xmlTextReaderReadDtoDtoHostsInfoType(xmlTextReaderPtr reader);

/**
 * Writes a DtoHostsInfo to XML.
 *
 * @param writer The XML writer.
 * @param _dtoHostsInfo The DtoHostsInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoHostsInfoType(xmlTextWriterPtr writer, struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo);

/**
 * Frees the elements of a DtoHostsInfo.
 *
 * @param _dtoHostsInfo The DtoHostsInfo to free.
 */
static void freeDtoDtoHostsInfoType(struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo);

#endif /* DEF_Grisu_dto_dtoHostsInfo_H */
#ifndef DEF_Grisu_dto_dtoJob_H
#define DEF_Grisu_dto_dtoJob_H

/**
 *  This one holds information about a job that was created (and maybe already
 submitted to the endpoint resource).
 
 You can use this to query information like job-directory and status of the
 job. Have a look in the Constants class in the GlueInterface module of the
 Infosystems project for values of keys of possible job properties.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoJob {


  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoLogMessages *logMessages;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoJobProperty *properties;

  /**
   * Size of the properties array.
   */
  int _sizeof_properties;

  /**
   * (no documentation provided)
   */
  int status;
};

/**
 * Reads a DtoJob element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}job", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoJob, or NULL in case of error.
 */
struct Grisu_dto_dtoJob *xml_read_Grisu_dto_dtoJob(xmlTextReaderPtr reader);

/**
 * Writes a DtoJob to XML under element name "{http://api.grisu.arcs.org.au/dto}job".
 *
 * @param writer The XML writer.
 * @param _dtoJob The DtoJob to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoJob(xmlTextWriterPtr writer, struct Grisu_dto_dtoJob *_dtoJob);

/**
 * Frees a DtoJob.
 *
 * @param _dtoJob The DtoJob to free.
 */
void free_Grisu_dto_dtoJob(struct Grisu_dto_dtoJob *_dtoJob);

/**
 * Reads a DtoJob element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}job", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoJob, or NULL in case of error.
 */
struct Grisu_dto_dtoJob *xmlTextReaderReadDtoJobElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoJob to XML under element name "{http://api.grisu.arcs.org.au/dto}job".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoJob The DtoJob to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoJobElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoJob *_dtoJob);

/**
 * Writes a DtoJob to XML under element name "{http://api.grisu.arcs.org.au/dto}job".
 *
 * @param writer The XML writer.
 * @param _dtoJob The DtoJob to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoJobElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoJob *_dtoJob, int writeNamespaces);

/**
 * Frees the children of a DtoJob.
 *
 * @param _dtoJob The DtoJob whose children are to be free.
 */
static void freeDtoJobElement(struct Grisu_dto_dtoJob *_dtoJob);

/**
 * Reads a DtoJob from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoJob, or NULL in case of error.
 */
static struct Grisu_dto_dtoJob *xmlTextReaderReadDtoDtoJobType(xmlTextReaderPtr reader);

/**
 * Writes a DtoJob to XML.
 *
 * @param writer The XML writer.
 * @param _dtoJob The DtoJob to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoJobType(xmlTextWriterPtr writer, struct Grisu_dto_dtoJob *_dtoJob);

/**
 * Frees the elements of a DtoJob.
 *
 * @param _dtoJob The DtoJob to free.
 */
static void freeDtoDtoJobType(struct Grisu_dto_dtoJob *_dtoJob);

#endif /* DEF_Grisu_dto_dtoJob_H */
#ifndef DEF_Grisu_dto_dtoJobProperty_H
#define DEF_Grisu_dto_dtoJobProperty_H

/**
 *  A wrapper class that holds a job property key and value.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoJobProperty {


  /**
   * (no documentation provided)
   */
  xmlChar *key;

  /**
   * (no documentation provided)
   */
  xmlChar *value;
};

/**
 * Reads a DtoJobProperty element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}jobproperty", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoJobProperty, or NULL in case of error.
 */
struct Grisu_dto_dtoJobProperty *xml_read_Grisu_dto_dtoJobProperty(xmlTextReaderPtr reader);

/**
 * Writes a DtoJobProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}jobproperty".
 *
 * @param writer The XML writer.
 * @param _dtoJobProperty The DtoJobProperty to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoJobProperty(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobProperty *_dtoJobProperty);

/**
 * Frees a DtoJobProperty.
 *
 * @param _dtoJobProperty The DtoJobProperty to free.
 */
void free_Grisu_dto_dtoJobProperty(struct Grisu_dto_dtoJobProperty *_dtoJobProperty);

/**
 * Reads a DtoJobProperty element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}jobproperty", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoJobProperty, or NULL in case of error.
 */
struct Grisu_dto_dtoJobProperty *xmlTextReaderReadDtoJobpropertyElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoJobProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}jobproperty".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoJobProperty The DtoJobProperty to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoJobpropertyElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobProperty *_dtoJobProperty);

/**
 * Writes a DtoJobProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}jobproperty".
 *
 * @param writer The XML writer.
 * @param _dtoJobProperty The DtoJobProperty to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoJobpropertyElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobProperty *_dtoJobProperty, int writeNamespaces);

/**
 * Frees the children of a DtoJobProperty.
 *
 * @param _dtoJobProperty The DtoJobProperty whose children are to be free.
 */
static void freeDtoJobpropertyElement(struct Grisu_dto_dtoJobProperty *_dtoJobProperty);

/**
 * Reads a DtoJobProperty from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoJobProperty, or NULL in case of error.
 */
static struct Grisu_dto_dtoJobProperty *xmlTextReaderReadDtoDtoJobPropertyType(xmlTextReaderPtr reader);

/**
 * Writes a DtoJobProperty to XML.
 *
 * @param writer The XML writer.
 * @param _dtoJobProperty The DtoJobProperty to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoJobPropertyType(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobProperty *_dtoJobProperty);

/**
 * Frees the elements of a DtoJobProperty.
 *
 * @param _dtoJobProperty The DtoJobProperty to free.
 */
static void freeDtoDtoJobPropertyType(struct Grisu_dto_dtoJobProperty *_dtoJobProperty);

#endif /* DEF_Grisu_dto_dtoJobProperty_H */
#ifndef DEF_Grisu_dto_dtoJobs_H
#define DEF_Grisu_dto_dtoJobs_H

/**
 *  A wrapper object that holds a list of {@link DtoJob} objects.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoJobs {


  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoJob *allJobs;

  /**
   * Size of the allJobs array.
   */
  int _sizeof_allJobs;
};

/**
 * Reads a DtoJobs element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}jobs", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoJobs, or NULL in case of error.
 */
struct Grisu_dto_dtoJobs *xml_read_Grisu_dto_dtoJobs(xmlTextReaderPtr reader);

/**
 * Writes a DtoJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}jobs".
 *
 * @param writer The XML writer.
 * @param _dtoJobs The DtoJobs to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoJobs(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobs *_dtoJobs);

/**
 * Frees a DtoJobs.
 *
 * @param _dtoJobs The DtoJobs to free.
 */
void free_Grisu_dto_dtoJobs(struct Grisu_dto_dtoJobs *_dtoJobs);

/**
 * Reads a DtoJobs element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}jobs", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoJobs, or NULL in case of error.
 */
struct Grisu_dto_dtoJobs *xmlTextReaderReadDtoJobsElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}jobs".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoJobs The DtoJobs to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoJobsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobs *_dtoJobs);

/**
 * Writes a DtoJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}jobs".
 *
 * @param writer The XML writer.
 * @param _dtoJobs The DtoJobs to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoJobsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobs *_dtoJobs, int writeNamespaces);

/**
 * Frees the children of a DtoJobs.
 *
 * @param _dtoJobs The DtoJobs whose children are to be free.
 */
static void freeDtoJobsElement(struct Grisu_dto_dtoJobs *_dtoJobs);

/**
 * Reads a DtoJobs from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoJobs, or NULL in case of error.
 */
static struct Grisu_dto_dtoJobs *xmlTextReaderReadDtoDtoJobsType(xmlTextReaderPtr reader);

/**
 * Writes a DtoJobs to XML.
 *
 * @param writer The XML writer.
 * @param _dtoJobs The DtoJobs to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoJobsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobs *_dtoJobs);

/**
 * Frees the elements of a DtoJobs.
 *
 * @param _dtoJobs The DtoJobs to free.
 */
static void freeDtoDtoJobsType(struct Grisu_dto_dtoJobs *_dtoJobs);

#endif /* DEF_Grisu_dto_dtoJobs_H */
#ifndef DEF_Grisu_dto_dtoLogItem_H
#define DEF_Grisu_dto_dtoLogItem_H

/**
 * (no documentation provided)
 */
struct Grisu_dto_dtoLogItem {


  /**
   * (no documentation provided)
   */
  struct tm *time;

  /**
   * (no documentation provided)
   */
  xmlChar *logMessage;
};

/**
 * Reads a DtoLogItem element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}dtoLogItem", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoLogItem, or NULL in case of error.
 */
struct Grisu_dto_dtoLogItem *xml_read_Grisu_dto_dtoLogItem(xmlTextReaderPtr reader);

/**
 * Writes a DtoLogItem to XML under element name "{http://api.grisu.arcs.org.au/dto}dtoLogItem".
 *
 * @param writer The XML writer.
 * @param _dtoLogItem The DtoLogItem to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoLogItem(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogItem *_dtoLogItem);

/**
 * Frees a DtoLogItem.
 *
 * @param _dtoLogItem The DtoLogItem to free.
 */
void free_Grisu_dto_dtoLogItem(struct Grisu_dto_dtoLogItem *_dtoLogItem);

/**
 * Reads a DtoLogItem element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}dtoLogItem", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoLogItem, or NULL in case of error.
 */
struct Grisu_dto_dtoLogItem *xmlTextReaderReadDtoDtoLogItemElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoLogItem to XML under element name "{http://api.grisu.arcs.org.au/dto}dtoLogItem".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoLogItem The DtoLogItem to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoLogItemElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogItem *_dtoLogItem);

/**
 * Writes a DtoLogItem to XML under element name "{http://api.grisu.arcs.org.au/dto}dtoLogItem".
 *
 * @param writer The XML writer.
 * @param _dtoLogItem The DtoLogItem to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoLogItemElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogItem *_dtoLogItem, int writeNamespaces);

/**
 * Frees the children of a DtoLogItem.
 *
 * @param _dtoLogItem The DtoLogItem whose children are to be free.
 */
static void freeDtoDtoLogItemElement(struct Grisu_dto_dtoLogItem *_dtoLogItem);

/**
 * Reads a DtoLogItem from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoLogItem, or NULL in case of error.
 */
static struct Grisu_dto_dtoLogItem *xmlTextReaderReadDtoDtoLogItemType(xmlTextReaderPtr reader);

/**
 * Writes a DtoLogItem to XML.
 *
 * @param writer The XML writer.
 * @param _dtoLogItem The DtoLogItem to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoLogItemType(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogItem *_dtoLogItem);

/**
 * Frees the elements of a DtoLogItem.
 *
 * @param _dtoLogItem The DtoLogItem to free.
 */
static void freeDtoDtoLogItemType(struct Grisu_dto_dtoLogItem *_dtoLogItem);

#endif /* DEF_Grisu_dto_dtoLogItem_H */
#ifndef DEF_Grisu_dto_dtoLogMessage_H
#define DEF_Grisu_dto_dtoLogMessage_H

/**
 * (no documentation provided)
 */
struct Grisu_dto_dtoLogMessage {


  /**
   * (no documentation provided)
   */
  struct tm *date;

  /**
   * (no documentation provided)
   */
  xmlChar *message;
};

/**
 * Reads a DtoLogMessage element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}logMessage", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoLogMessage, or NULL in case of error.
 */
struct Grisu_dto_dtoLogMessage *xml_read_Grisu_dto_dtoLogMessage(xmlTextReaderPtr reader);

/**
 * Writes a DtoLogMessage to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessage".
 *
 * @param writer The XML writer.
 * @param _dtoLogMessage The DtoLogMessage to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoLogMessage(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessage *_dtoLogMessage);

/**
 * Frees a DtoLogMessage.
 *
 * @param _dtoLogMessage The DtoLogMessage to free.
 */
void free_Grisu_dto_dtoLogMessage(struct Grisu_dto_dtoLogMessage *_dtoLogMessage);

/**
 * Reads a DtoLogMessage element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}logMessage", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoLogMessage, or NULL in case of error.
 */
struct Grisu_dto_dtoLogMessage *xmlTextReaderReadDtoLogMessageElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoLogMessage to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessage".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoLogMessage The DtoLogMessage to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoLogMessageElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessage *_dtoLogMessage);

/**
 * Writes a DtoLogMessage to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessage".
 *
 * @param writer The XML writer.
 * @param _dtoLogMessage The DtoLogMessage to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoLogMessageElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessage *_dtoLogMessage, int writeNamespaces);

/**
 * Frees the children of a DtoLogMessage.
 *
 * @param _dtoLogMessage The DtoLogMessage whose children are to be free.
 */
static void freeDtoLogMessageElement(struct Grisu_dto_dtoLogMessage *_dtoLogMessage);

/**
 * Reads a DtoLogMessage from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoLogMessage, or NULL in case of error.
 */
static struct Grisu_dto_dtoLogMessage *xmlTextReaderReadDtoDtoLogMessageType(xmlTextReaderPtr reader);

/**
 * Writes a DtoLogMessage to XML.
 *
 * @param writer The XML writer.
 * @param _dtoLogMessage The DtoLogMessage to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoLogMessageType(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessage *_dtoLogMessage);

/**
 * Frees the elements of a DtoLogMessage.
 *
 * @param _dtoLogMessage The DtoLogMessage to free.
 */
static void freeDtoDtoLogMessageType(struct Grisu_dto_dtoLogMessage *_dtoLogMessage);

#endif /* DEF_Grisu_dto_dtoLogMessage_H */
#ifndef DEF_Grisu_dto_dtoLogMessages_H
#define DEF_Grisu_dto_dtoLogMessages_H

/**
 * (no documentation provided)
 */
struct Grisu_dto_dtoLogMessages {


  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoLogMessage *messages;

  /**
   * Size of the messages array.
   */
  int _sizeof_messages;
};

/**
 * Reads a DtoLogMessages element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}logMessages", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoLogMessages, or NULL in case of error.
 */
struct Grisu_dto_dtoLogMessages *xml_read_Grisu_dto_dtoLogMessages(xmlTextReaderPtr reader);

/**
 * Writes a DtoLogMessages to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessages".
 *
 * @param writer The XML writer.
 * @param _dtoLogMessages The DtoLogMessages to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoLogMessages(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessages *_dtoLogMessages);

/**
 * Frees a DtoLogMessages.
 *
 * @param _dtoLogMessages The DtoLogMessages to free.
 */
void free_Grisu_dto_dtoLogMessages(struct Grisu_dto_dtoLogMessages *_dtoLogMessages);

/**
 * Reads a DtoLogMessages element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}logMessages", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoLogMessages, or NULL in case of error.
 */
struct Grisu_dto_dtoLogMessages *xmlTextReaderReadDtoLogMessagesElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoLogMessages to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessages".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoLogMessages The DtoLogMessages to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoLogMessagesElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessages *_dtoLogMessages);

/**
 * Writes a DtoLogMessages to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessages".
 *
 * @param writer The XML writer.
 * @param _dtoLogMessages The DtoLogMessages to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoLogMessagesElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessages *_dtoLogMessages, int writeNamespaces);

/**
 * Frees the children of a DtoLogMessages.
 *
 * @param _dtoLogMessages The DtoLogMessages whose children are to be free.
 */
static void freeDtoLogMessagesElement(struct Grisu_dto_dtoLogMessages *_dtoLogMessages);

/**
 * Reads a DtoLogMessages from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoLogMessages, or NULL in case of error.
 */
static struct Grisu_dto_dtoLogMessages *xmlTextReaderReadDtoDtoLogMessagesType(xmlTextReaderPtr reader);

/**
 * Writes a DtoLogMessages to XML.
 *
 * @param writer The XML writer.
 * @param _dtoLogMessages The DtoLogMessages to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoLogMessagesType(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessages *_dtoLogMessages);

/**
 * Frees the elements of a DtoLogMessages.
 *
 * @param _dtoLogMessages The DtoLogMessages to free.
 */
static void freeDtoDtoLogMessagesType(struct Grisu_dto_dtoLogMessages *_dtoLogMessages);

#endif /* DEF_Grisu_dto_dtoLogMessages_H */
#ifndef DEF_Grisu_dto_dtoMountPoints_H
#define DEF_Grisu_dto_dtoMountPoints_H

/**
 *  A wrapper that holds a list of mountpoints.
 
 These are all the mountpoints a user has access to.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoMountPoints {


  /**
   * (no documentation provided)
   */
  struct Grisu_dto_mountPoint *mountpoints;

  /**
   * Size of the mountpoints array.
   */
  int _sizeof_mountpoints;
};

/**
 * Reads a DtoMountPoints element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}mountpoints", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoMountPoints, or NULL in case of error.
 */
struct Grisu_dto_dtoMountPoints *xml_read_Grisu_dto_dtoMountPoints(xmlTextReaderPtr reader);

/**
 * Writes a DtoMountPoints to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoints".
 *
 * @param writer The XML writer.
 * @param _dtoMountPoints The DtoMountPoints to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoMountPoints(xmlTextWriterPtr writer, struct Grisu_dto_dtoMountPoints *_dtoMountPoints);

/**
 * Frees a DtoMountPoints.
 *
 * @param _dtoMountPoints The DtoMountPoints to free.
 */
void free_Grisu_dto_dtoMountPoints(struct Grisu_dto_dtoMountPoints *_dtoMountPoints);

/**
 * Reads a DtoMountPoints element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}mountpoints", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoMountPoints, or NULL in case of error.
 */
struct Grisu_dto_dtoMountPoints *xmlTextReaderReadDtoMountpointsElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoMountPoints to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoints".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoMountPoints The DtoMountPoints to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoMountpointsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoMountPoints *_dtoMountPoints);

/**
 * Writes a DtoMountPoints to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoints".
 *
 * @param writer The XML writer.
 * @param _dtoMountPoints The DtoMountPoints to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoMountpointsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoMountPoints *_dtoMountPoints, int writeNamespaces);

/**
 * Frees the children of a DtoMountPoints.
 *
 * @param _dtoMountPoints The DtoMountPoints whose children are to be free.
 */
static void freeDtoMountpointsElement(struct Grisu_dto_dtoMountPoints *_dtoMountPoints);

/**
 * Reads a DtoMountPoints from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoMountPoints, or NULL in case of error.
 */
static struct Grisu_dto_dtoMountPoints *xmlTextReaderReadDtoDtoMountPointsType(xmlTextReaderPtr reader);

/**
 * Writes a DtoMountPoints to XML.
 *
 * @param writer The XML writer.
 * @param _dtoMountPoints The DtoMountPoints to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoMountPointsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoMountPoints *_dtoMountPoints);

/**
 * Frees the elements of a DtoMountPoints.
 *
 * @param _dtoMountPoints The DtoMountPoints to free.
 */
static void freeDtoDtoMountPointsType(struct Grisu_dto_dtoMountPoints *_dtoMountPoints);

#endif /* DEF_Grisu_dto_dtoMountPoints_H */
#ifndef DEF_Grisu_dto_dtoMultiPartJobs_H
#define DEF_Grisu_dto_dtoMultiPartJobs_H

/**
 * (no documentation provided)
 */
struct Grisu_dto_dtoMultiPartJobs {


  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoBatchJob *allJobs;

  /**
   * Size of the allJobs array.
   */
  int _sizeof_allJobs;
};

/**
 * Reads a DtoMultiPartJobs element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}multiPartJobs", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoMultiPartJobs, or NULL in case of error.
 */
struct Grisu_dto_dtoMultiPartJobs *xml_read_Grisu_dto_dtoMultiPartJobs(xmlTextReaderPtr reader);

/**
 * Writes a DtoMultiPartJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJobs".
 *
 * @param writer The XML writer.
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoMultiPartJobs(xmlTextWriterPtr writer, struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs);

/**
 * Frees a DtoMultiPartJobs.
 *
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to free.
 */
void free_Grisu_dto_dtoMultiPartJobs(struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs);

/**
 * Reads a DtoMultiPartJobs element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}multiPartJobs", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoMultiPartJobs, or NULL in case of error.
 */
struct Grisu_dto_dtoMultiPartJobs *xmlTextReaderReadDtoMultiPartJobsElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoMultiPartJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJobs".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoMultiPartJobsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs);

/**
 * Writes a DtoMultiPartJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJobs".
 *
 * @param writer The XML writer.
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoMultiPartJobsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs, int writeNamespaces);

/**
 * Frees the children of a DtoMultiPartJobs.
 *
 * @param _dtoMultiPartJobs The DtoMultiPartJobs whose children are to be free.
 */
static void freeDtoMultiPartJobsElement(struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs);

/**
 * Reads a DtoMultiPartJobs from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoMultiPartJobs, or NULL in case of error.
 */
static struct Grisu_dto_dtoMultiPartJobs *xmlTextReaderReadDtoDtoMultiPartJobsType(xmlTextReaderPtr reader);

/**
 * Writes a DtoMultiPartJobs to XML.
 *
 * @param writer The XML writer.
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoMultiPartJobsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs);

/**
 * Frees the elements of a DtoMultiPartJobs.
 *
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to free.
 */
static void freeDtoDtoMultiPartJobsType(struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs);

#endif /* DEF_Grisu_dto_dtoMultiPartJobs_H */
#ifndef DEF_Grisu_dto_dtoProperties_H
#define DEF_Grisu_dto_dtoProperties_H

/**
 *  This one holds information about a job that was created (and maybe already
 submitted to the endpoint resource).
 
 You can use this to query information like job-directory and status of the
 job. Have a look in the Constants class in the GlueInterface module of the
 Infosystems project for values of keys of possible job properties.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoProperties {


  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoProperty *properties;

  /**
   * Size of the properties array.
   */
  int _sizeof_properties;
};

/**
 * Reads a DtoProperties element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}userproperties", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoProperties, or NULL in case of error.
 */
struct Grisu_dto_dtoProperties *xml_read_Grisu_dto_dtoProperties(xmlTextReaderPtr reader);

/**
 * Writes a DtoProperties to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperties".
 *
 * @param writer The XML writer.
 * @param _dtoProperties The DtoProperties to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoProperties(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperties *_dtoProperties);

/**
 * Frees a DtoProperties.
 *
 * @param _dtoProperties The DtoProperties to free.
 */
void free_Grisu_dto_dtoProperties(struct Grisu_dto_dtoProperties *_dtoProperties);

/**
 * Reads a DtoProperties element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}userproperties", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoProperties, or NULL in case of error.
 */
struct Grisu_dto_dtoProperties *xmlTextReaderReadDtoUserpropertiesElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoProperties to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperties".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoProperties The DtoProperties to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoUserpropertiesElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperties *_dtoProperties);

/**
 * Writes a DtoProperties to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperties".
 *
 * @param writer The XML writer.
 * @param _dtoProperties The DtoProperties to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoUserpropertiesElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperties *_dtoProperties, int writeNamespaces);

/**
 * Frees the children of a DtoProperties.
 *
 * @param _dtoProperties The DtoProperties whose children are to be free.
 */
static void freeDtoUserpropertiesElement(struct Grisu_dto_dtoProperties *_dtoProperties);

/**
 * Reads a DtoProperties from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoProperties, or NULL in case of error.
 */
static struct Grisu_dto_dtoProperties *xmlTextReaderReadDtoDtoPropertiesType(xmlTextReaderPtr reader);

/**
 * Writes a DtoProperties to XML.
 *
 * @param writer The XML writer.
 * @param _dtoProperties The DtoProperties to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoPropertiesType(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperties *_dtoProperties);

/**
 * Frees the elements of a DtoProperties.
 *
 * @param _dtoProperties The DtoProperties to free.
 */
static void freeDtoDtoPropertiesType(struct Grisu_dto_dtoProperties *_dtoProperties);

#endif /* DEF_Grisu_dto_dtoProperties_H */
#ifndef DEF_Grisu_dto_dtoProperty_H
#define DEF_Grisu_dto_dtoProperty_H

/**
 *  A wrapper class that holds a job property key and value.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoProperty {


  /**
   * (no documentation provided)
   */
  xmlChar *key;

  /**
   * (no documentation provided)
   */
  xmlChar *value;
};

/**
 * Reads a DtoProperty element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}userproperty", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoProperty, or NULL in case of error.
 */
struct Grisu_dto_dtoProperty *xml_read_Grisu_dto_dtoProperty(xmlTextReaderPtr reader);

/**
 * Writes a DtoProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperty".
 *
 * @param writer The XML writer.
 * @param _dtoProperty The DtoProperty to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoProperty(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperty *_dtoProperty);

/**
 * Frees a DtoProperty.
 *
 * @param _dtoProperty The DtoProperty to free.
 */
void free_Grisu_dto_dtoProperty(struct Grisu_dto_dtoProperty *_dtoProperty);

/**
 * Reads a DtoProperty element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}userproperty", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoProperty, or NULL in case of error.
 */
struct Grisu_dto_dtoProperty *xmlTextReaderReadDtoUserpropertyElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperty".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoProperty The DtoProperty to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoUserpropertyElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperty *_dtoProperty);

/**
 * Writes a DtoProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperty".
 *
 * @param writer The XML writer.
 * @param _dtoProperty The DtoProperty to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoUserpropertyElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperty *_dtoProperty, int writeNamespaces);

/**
 * Frees the children of a DtoProperty.
 *
 * @param _dtoProperty The DtoProperty whose children are to be free.
 */
static void freeDtoUserpropertyElement(struct Grisu_dto_dtoProperty *_dtoProperty);

/**
 * Reads a DtoProperty from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoProperty, or NULL in case of error.
 */
static struct Grisu_dto_dtoProperty *xmlTextReaderReadDtoDtoPropertyType(xmlTextReaderPtr reader);

/**
 * Writes a DtoProperty to XML.
 *
 * @param writer The XML writer.
 * @param _dtoProperty The DtoProperty to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoPropertyType(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperty *_dtoProperty);

/**
 * Frees the elements of a DtoProperty.
 *
 * @param _dtoProperty The DtoProperty to free.
 */
static void freeDtoDtoPropertyType(struct Grisu_dto_dtoProperty *_dtoProperty);

#endif /* DEF_Grisu_dto_dtoProperty_H */
#ifndef DEF_Grisu_dto_dtoStringList_H
#define DEF_Grisu_dto_dtoStringList_H

/**
 * (no documentation provided)
 */
struct Grisu_dto_dtoStringList {


  /**
   * (no documentation provided)
   */
  xmlChar *stringList;

  /**
   * Size of the stringList array.
   */
  int _sizeof_stringList;
};

/**
 * Reads a DtoStringList element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}list", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoStringList, or NULL in case of error.
 */
struct Grisu_dto_dtoStringList *xml_read_Grisu_dto_dtoStringList(xmlTextReaderPtr reader);

/**
 * Writes a DtoStringList to XML under element name "{http://api.grisu.arcs.org.au/dto}list".
 *
 * @param writer The XML writer.
 * @param _dtoStringList The DtoStringList to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoStringList(xmlTextWriterPtr writer, struct Grisu_dto_dtoStringList *_dtoStringList);

/**
 * Frees a DtoStringList.
 *
 * @param _dtoStringList The DtoStringList to free.
 */
void free_Grisu_dto_dtoStringList(struct Grisu_dto_dtoStringList *_dtoStringList);

/**
 * Reads a DtoStringList element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}list", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoStringList, or NULL in case of error.
 */
struct Grisu_dto_dtoStringList *xmlTextReaderReadDtoListElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoStringList to XML under element name "{http://api.grisu.arcs.org.au/dto}list".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoStringList The DtoStringList to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoListElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoStringList *_dtoStringList);

/**
 * Writes a DtoStringList to XML under element name "{http://api.grisu.arcs.org.au/dto}list".
 *
 * @param writer The XML writer.
 * @param _dtoStringList The DtoStringList to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoListElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoStringList *_dtoStringList, int writeNamespaces);

/**
 * Frees the children of a DtoStringList.
 *
 * @param _dtoStringList The DtoStringList whose children are to be free.
 */
static void freeDtoListElement(struct Grisu_dto_dtoStringList *_dtoStringList);

/**
 * Reads a DtoStringList from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoStringList, or NULL in case of error.
 */
static struct Grisu_dto_dtoStringList *xmlTextReaderReadDtoDtoStringListType(xmlTextReaderPtr reader);

/**
 * Writes a DtoStringList to XML.
 *
 * @param writer The XML writer.
 * @param _dtoStringList The DtoStringList to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoStringListType(xmlTextWriterPtr writer, struct Grisu_dto_dtoStringList *_dtoStringList);

/**
 * Frees the elements of a DtoStringList.
 *
 * @param _dtoStringList The DtoStringList to free.
 */
static void freeDtoDtoStringListType(struct Grisu_dto_dtoStringList *_dtoStringList);

#endif /* DEF_Grisu_dto_dtoStringList_H */
#ifndef DEF_Grisu_dto_dtoSubmissionLocationInfo_H
#define DEF_Grisu_dto_dtoSubmissionLocationInfo_H

/**
 *  A wrapper object for the submission location.
 
 At the moment this only holds the submissionlocation itself, but I may add
 things like sitename and such later on.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoSubmissionLocationInfo {


  /**
   * (no documentation provided)
   */
  xmlChar *submissionLocation;
};

/**
 * Reads a DtoSubmissionLocationInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}submissionlocation", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoSubmissionLocationInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoSubmissionLocationInfo *xml_read_Grisu_dto_dtoSubmissionLocationInfo(xmlTextReaderPtr reader);

/**
 * Writes a DtoSubmissionLocationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocation".
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoSubmissionLocationInfo(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo);

/**
 * Frees a DtoSubmissionLocationInfo.
 *
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to free.
 */
void free_Grisu_dto_dtoSubmissionLocationInfo(struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo);

/**
 * Reads a DtoSubmissionLocationInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}submissionlocation", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoSubmissionLocationInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoSubmissionLocationInfo *xmlTextReaderReadDtoSubmissionlocationElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoSubmissionLocationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocation".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoSubmissionlocationElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo);

/**
 * Writes a DtoSubmissionLocationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocation".
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoSubmissionlocationElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo, int writeNamespaces);

/**
 * Frees the children of a DtoSubmissionLocationInfo.
 *
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo whose children are to be free.
 */
static void freeDtoSubmissionlocationElement(struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo);

/**
 * Reads a DtoSubmissionLocationInfo from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoSubmissionLocationInfo, or NULL in case of error.
 */
static struct Grisu_dto_dtoSubmissionLocationInfo *xmlTextReaderReadDtoDtoSubmissionLocationInfoType(xmlTextReaderPtr reader);

/**
 * Writes a DtoSubmissionLocationInfo to XML.
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoSubmissionLocationInfoType(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo);

/**
 * Frees the elements of a DtoSubmissionLocationInfo.
 *
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to free.
 */
static void freeDtoDtoSubmissionLocationInfoType(struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo);

#endif /* DEF_Grisu_dto_dtoSubmissionLocationInfo_H */
#ifndef DEF_Grisu_dto_dtoSubmissionLocations_H
#define DEF_Grisu_dto_dtoSubmissionLocations_H

/**
 *  A wrapper that holds a list of {@link DtoSubmissionLocationInfo} objects.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoSubmissionLocations {


  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoSubmissionLocationInfo *allSubmissionLocations;

  /**
   * Size of the allSubmissionLocations array.
   */
  int _sizeof_allSubmissionLocations;
};

/**
 * Reads a DtoSubmissionLocations element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}submissionlocations", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoSubmissionLocations, or NULL in case of error.
 */
struct Grisu_dto_dtoSubmissionLocations *xml_read_Grisu_dto_dtoSubmissionLocations(xmlTextReaderPtr reader);

/**
 * Writes a DtoSubmissionLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocations".
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoSubmissionLocations(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations);

/**
 * Frees a DtoSubmissionLocations.
 *
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to free.
 */
void free_Grisu_dto_dtoSubmissionLocations(struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations);

/**
 * Reads a DtoSubmissionLocations element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}submissionlocations", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoSubmissionLocations, or NULL in case of error.
 */
struct Grisu_dto_dtoSubmissionLocations *xmlTextReaderReadDtoSubmissionlocationsElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoSubmissionLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocations".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoSubmissionlocationsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations);

/**
 * Writes a DtoSubmissionLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocations".
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoSubmissionlocationsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations, int writeNamespaces);

/**
 * Frees the children of a DtoSubmissionLocations.
 *
 * @param _dtoSubmissionLocations The DtoSubmissionLocations whose children are to be free.
 */
static void freeDtoSubmissionlocationsElement(struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations);

/**
 * Reads a DtoSubmissionLocations from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoSubmissionLocations, or NULL in case of error.
 */
static struct Grisu_dto_dtoSubmissionLocations *xmlTextReaderReadDtoDtoSubmissionLocationsType(xmlTextReaderPtr reader);

/**
 * Writes a DtoSubmissionLocations to XML.
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoSubmissionLocationsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations);

/**
 * Frees the elements of a DtoSubmissionLocations.
 *
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to free.
 */
static void freeDtoDtoSubmissionLocationsType(struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations);

#endif /* DEF_Grisu_dto_dtoSubmissionLocations_H */
#ifndef DEF_Grisu_dto_dtoVersionInfo_H
#define DEF_Grisu_dto_dtoVersionInfo_H

/**
 *  This one contains a list of submission locations (that are available for a
 certain VO) of a specific version of an application.
 
 @author Markus Binsteiner
 

 */
struct Grisu_dto_dtoVersionInfo {


  /**
   * (no documentation provided)
   */
  xmlChar *name;

  /**
   * (no documentation provided)
   */
  struct Grisu_dto_dtoSubmissionLocations *allSubmissionLocations;
};

/**
 * Reads a DtoVersionInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}version", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoVersionInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoVersionInfo *xml_read_Grisu_dto_dtoVersionInfo(xmlTextReaderPtr reader);

/**
 * Writes a DtoVersionInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}version".
 *
 * @param writer The XML writer.
 * @param _dtoVersionInfo The DtoVersionInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_Grisu_dto_dtoVersionInfo(xmlTextWriterPtr writer, struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo);

/**
 * Frees a DtoVersionInfo.
 *
 * @param _dtoVersionInfo The DtoVersionInfo to free.
 */
void free_Grisu_dto_dtoVersionInfo(struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo);

/**
 * Reads a DtoVersionInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}version", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The DtoVersionInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoVersionInfo *xmlTextReaderReadDtoVersionElement(xmlTextReaderPtr reader);

/**
 * Writes a DtoVersionInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}version".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoVersionInfo The DtoVersionInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoVersionElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo);

/**
 * Writes a DtoVersionInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}version".
 *
 * @param writer The XML writer.
 * @param _dtoVersionInfo The DtoVersionInfo to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoVersionElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo, int writeNamespaces);

/**
 * Frees the children of a DtoVersionInfo.
 *
 * @param _dtoVersionInfo The DtoVersionInfo whose children are to be free.
 */
static void freeDtoVersionElement(struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo);

/**
 * Reads a DtoVersionInfo from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The DtoVersionInfo, or NULL in case of error.
 */
static struct Grisu_dto_dtoVersionInfo *xmlTextReaderReadDtoDtoVersionInfoType(xmlTextReaderPtr reader);

/**
 * Writes a DtoVersionInfo to XML.
 *
 * @param writer The XML writer.
 * @param _dtoVersionInfo The DtoVersionInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteDtoDtoVersionInfoType(xmlTextWriterPtr writer, struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo);

/**
 * Frees the elements of a DtoVersionInfo.
 *
 * @param _dtoVersionInfo The DtoVersionInfo to free.
 */
static void freeDtoDtoVersionInfoType(struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo);

#endif /* DEF_Grisu_dto_dtoVersionInfo_H */
#ifndef DEF_Grisu_dto_mountPoint_M
#define DEF_Grisu_dto_mountPoint_M

/**
 * Reads a MountPoint element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}mountpoint", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The MountPoint, or NULL in case of error.
 */
struct Grisu_dto_mountPoint *xml_read_Grisu_dto_mountPoint(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoMountpointElement(reader);
}

/**
 * Writes a MountPoint to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoint".
 *
 * @param writer The XML writer.
 * @param _mountPoint The MountPoint to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_mountPoint(xmlTextWriterPtr writer, struct Grisu_dto_mountPoint *_mountPoint) {
  return xmlTextWriterWriteDtoMountpointElementNS(writer, _mountPoint, 1);
}

/**
 * Frees a MountPoint.
 *
 * @param _mountPoint The MountPoint to free.
 */
void free_Grisu_dto_mountPoint(struct Grisu_dto_mountPoint *_mountPoint) {
  freeDtoMountPointType(_mountPoint);
  free(_mountPoint);
}

/**
 * Reads a MountPoint element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}mountpoint", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The MountPoint, or NULL in case of error.
 */
struct Grisu_dto_mountPoint *xmlTextReaderReadDtoMountpointElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_mountPoint *_mountPoint = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "mountpoint", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}mountpoint.\n");
#endif
    _mountPoint = xmlTextReaderReadDtoMountPointType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_mountPoint == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}mountpoint failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}mountpoint failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _mountPoint;
}

/**
 * Writes a MountPoint to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoint".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _mountPoint The MountPoint to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoMountpointElement(xmlTextWriterPtr writer, struct Grisu_dto_mountPoint *_mountPoint) {
  return xmlTextWriterWriteDtoMountpointElementNS(writer, _mountPoint, 0);
}

/**
 * Writes a MountPoint to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoint".
 *
 * @param writer The XML writer.
 * @param _mountPoint The MountPoint to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoMountpointElementNS(xmlTextWriterPtr writer, struct Grisu_dto_mountPoint *_mountPoint, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "mountpoint", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}mountpoint. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}mountpoint...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}mountPoint for root element {http://api.grisu.arcs.org.au/dto}mountpoint...\n");
#endif
  status = xmlTextWriterWriteDtoMountPointType(writer, _mountPoint);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}mountpoint. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}mountpoint. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a MountPoint.
 *
 * @param _mountPoint The MountPoint whose children are to be free.
 */
static void freeDtoMountpointElement(struct Grisu_dto_mountPoint *_mountPoint) {
  freeDtoMountPointType(_mountPoint);
}

/**
 * Reads a MountPoint from XML. The reader is assumed to be at the start element.
 *
 * @return the MountPoint, or NULL in case of error.
 */
static struct Grisu_dto_mountPoint *xmlTextReaderReadDtoMountPointType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_mountPoint *_mountPoint = calloc(1, sizeof(struct Grisu_dto_mountPoint));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "url", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}url...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}url of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoMountPointType(_mountPoint);
          free(_mountPoint);
          return NULL;
        }
        _mountPoint->rootUrl = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "alias", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}alias...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}alias of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoMountPointType(_mountPoint);
          free(_mountPoint);
          return NULL;
        }
        _mountPoint->alias = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoMountPointType(_mountPoint);
      free(_mountPoint);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoMountPointType(_mountPoint);
        free(_mountPoint);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "dn", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}dn of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}dn of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoMountPointType(_mountPoint);
          free(_mountPoint);
          return NULL;
        }

        _mountPoint->dn = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "fqan", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}fqan of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}fqan of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoMountPointType(_mountPoint);
          free(_mountPoint);
          return NULL;
        }

        _mountPoint->fqan = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "site", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}site of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}site of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoMountPointType(_mountPoint);
          free(_mountPoint);
          return NULL;
        }

        _mountPoint->site = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "automounted", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}automounted of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}automounted of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoMountPointType(_mountPoint);
          free(_mountPoint);
          return NULL;
        }

        _mountPoint->automaticallyMounted = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "disabled", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}disabled of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}disabled of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoMountPointType(_mountPoint);
          free(_mountPoint);
          return NULL;
        }

        _mountPoint->disabled = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}mountPoint.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}mountPoint. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _mountPoint;
}

/**
 * Writes a MountPoint to XML.
 *
 * @param writer The XML writer.
 * @param _mountPoint The MountPoint to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoMountPointType(xmlTextWriterPtr writer, struct Grisu_dto_mountPoint *_mountPoint) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_mountPoint->rootUrl != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "url", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}url. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}url...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_mountPoint->rootUrl));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}url. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}url. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_mountPoint->alias != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "alias", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}alias. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}alias...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_mountPoint->alias));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}alias. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}alias. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_mountPoint->dn != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "dn", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}dn. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}dn...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_mountPoint->dn));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}dn. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}dn. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_mountPoint->fqan != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "fqan", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}fqan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}fqan...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_mountPoint->fqan));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}fqan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}fqan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_mountPoint->site != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "site", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}site. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}site...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_mountPoint->site));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}site. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}site. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "automounted", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}automounted. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}automounted...\n", status);
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_mountPoint->automaticallyMounted));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}automounted. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}automounted. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "disabled", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}disabled. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}disabled...\n", status);
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_mountPoint->disabled));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}disabled. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}disabled. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a MountPoint.
 *
 * @param _mountPoint The MountPoint to free.
 */
static void freeDtoMountPointType(struct Grisu_dto_mountPoint *_mountPoint) {
  int i;
  if (_mountPoint->rootUrl != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor rootUrl of type Grisu_dto_mountPoint...\n");
#endif
    freeXsStringType(_mountPoint->rootUrl);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor rootUrl of type Grisu_dto_mountPoint...\n");
#endif
    free(_mountPoint->rootUrl);
  }
  if (_mountPoint->alias != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor alias of type Grisu_dto_mountPoint...\n");
#endif
    freeXsStringType(_mountPoint->alias);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor alias of type Grisu_dto_mountPoint...\n");
#endif
    free(_mountPoint->alias);
  }
  if (_mountPoint->dn != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor dn of type Grisu_dto_mountPoint...\n");
#endif
    freeXsStringType(_mountPoint->dn);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor dn of type Grisu_dto_mountPoint...\n");
#endif
    free(_mountPoint->dn);
  }
  if (_mountPoint->fqan != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor fqan of type Grisu_dto_mountPoint...\n");
#endif
    freeXsStringType(_mountPoint->fqan);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor fqan of type Grisu_dto_mountPoint...\n");
#endif
    free(_mountPoint->fqan);
  }
  if (_mountPoint->site != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor site of type Grisu_dto_mountPoint...\n");
#endif
    freeXsStringType(_mountPoint->site);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor site of type Grisu_dto_mountPoint...\n");
#endif
    free(_mountPoint->site);
  }
}
#endif /* DEF_Grisu_dto_mountPoint_M */
#ifndef DEF_Grisu_dto_dtoActionStatus_M
#define DEF_Grisu_dto_dtoActionStatus_M

/**
 * Reads a DtoActionStatus element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}actionStatus", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoActionStatus, or NULL in case of error.
 */
struct Grisu_dto_dtoActionStatus *xml_read_Grisu_dto_dtoActionStatus(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoActionStatusElement(reader);
}

/**
 * Writes a DtoActionStatus to XML under element name "{http://api.grisu.arcs.org.au/dto}actionStatus".
 *
 * @param writer The XML writer.
 * @param _dtoActionStatus The DtoActionStatus to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoActionStatus(xmlTextWriterPtr writer, struct Grisu_dto_dtoActionStatus *_dtoActionStatus) {
  return xmlTextWriterWriteDtoActionStatusElementNS(writer, _dtoActionStatus, 1);
}

/**
 * Frees a DtoActionStatus.
 *
 * @param _dtoActionStatus The DtoActionStatus to free.
 */
void free_Grisu_dto_dtoActionStatus(struct Grisu_dto_dtoActionStatus *_dtoActionStatus) {
  freeDtoDtoActionStatusType(_dtoActionStatus);
  free(_dtoActionStatus);
}

/**
 * Reads a DtoActionStatus element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}actionStatus", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoActionStatus, or NULL in case of error.
 */
struct Grisu_dto_dtoActionStatus *xmlTextReaderReadDtoActionStatusElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoActionStatus *_dtoActionStatus = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "actionStatus", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}actionStatus.\n");
#endif
    _dtoActionStatus = xmlTextReaderReadDtoDtoActionStatusType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoActionStatus == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}actionStatus failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}actionStatus failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoActionStatus;
}

/**
 * Writes a DtoActionStatus to XML under element name "{http://api.grisu.arcs.org.au/dto}actionStatus".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoActionStatus The DtoActionStatus to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoActionStatusElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoActionStatus *_dtoActionStatus) {
  return xmlTextWriterWriteDtoActionStatusElementNS(writer, _dtoActionStatus, 0);
}

/**
 * Writes a DtoActionStatus to XML under element name "{http://api.grisu.arcs.org.au/dto}actionStatus".
 *
 * @param writer The XML writer.
 * @param _dtoActionStatus The DtoActionStatus to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoActionStatusElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoActionStatus *_dtoActionStatus, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "actionStatus", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}actionStatus. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}actionStatus...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoActionStatus for root element {http://api.grisu.arcs.org.au/dto}actionStatus...\n");
#endif
  status = xmlTextWriterWriteDtoDtoActionStatusType(writer, _dtoActionStatus);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}actionStatus. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}actionStatus. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoActionStatus.
 *
 * @param _dtoActionStatus The DtoActionStatus whose children are to be free.
 */
static void freeDtoActionStatusElement(struct Grisu_dto_dtoActionStatus *_dtoActionStatus) {
  freeDtoDtoActionStatusType(_dtoActionStatus);
}

/**
 * Reads a DtoActionStatus from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoActionStatus, or NULL in case of error.
 */
static struct Grisu_dto_dtoActionStatus *xmlTextReaderReadDtoDtoActionStatusType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoActionStatus *_dtoActionStatus = calloc(1, sizeof(struct Grisu_dto_dtoActionStatus));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "handle", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}handle...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}handle of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoActionStatusType(_dtoActionStatus);
          free(_dtoActionStatus);
          return NULL;
        }
        _dtoActionStatus->handle = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "lastUpdate", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}dateTime from attribute {}lastUpdate...\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateTimeType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}lastUpdate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
          freeDtoDtoActionStatusType(_dtoActionStatus);
          free(_dtoActionStatus);
          return NULL;
        }
        _dtoActionStatus->lastUpdate = ((struct tm*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "failed", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}boolean from attribute {}failed...\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}failed of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          freeDtoDtoActionStatusType(_dtoActionStatus);
          free(_dtoActionStatus);
          return NULL;
        }
        _dtoActionStatus->failed = *((int*)_child_accessor);
        freeXsBooleanType((int*) _child_accessor);
        free(_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "totalElements", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}int from attribute {}totalElements...\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}totalElements of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          freeDtoDtoActionStatusType(_dtoActionStatus);
          free(_dtoActionStatus);
          return NULL;
        }
        _dtoActionStatus->totalElements = *((int*)_child_accessor);
        freeXsIntType((int*) _child_accessor);
        free(_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "finished", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}boolean from attribute {}finished...\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}finished of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          freeDtoDtoActionStatusType(_dtoActionStatus);
          free(_dtoActionStatus);
          return NULL;
        }
        _dtoActionStatus->finished = *((int*)_child_accessor);
        freeXsBooleanType((int*) _child_accessor);
        free(_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoActionStatusType(_dtoActionStatus);
      free(_dtoActionStatus);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoActionStatusType(_dtoActionStatus);
        free(_dtoActionStatus);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "currentElements", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}currentElements of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}currentElements of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoActionStatusType(_dtoActionStatus);
          free(_dtoActionStatus);
          return NULL;
        }

        _dtoActionStatus->currentElements = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "log", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}log of type {http://api.grisu.arcs.org.au/dto}dtoLogItem.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoLogItemType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}log of type {http://api.grisu.arcs.org.au/dto}dtoLogItem.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoActionStatusType(_dtoActionStatus);
          free(_dtoActionStatus);
          return NULL;
        }

        _dtoActionStatus->log = realloc(_dtoActionStatus->log, (_dtoActionStatus->_sizeof_log + 1) * sizeof(struct Grisu_dto_dtoLogItem));
        memcpy(&(_dtoActionStatus->log[_dtoActionStatus->_sizeof_log++]), _child_accessor, sizeof(struct Grisu_dto_dtoLogItem));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoActionStatus.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoActionStatus. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoActionStatus;
}

/**
 * Writes a DtoActionStatus to XML.
 *
 * @param writer The XML writer.
 * @param _dtoActionStatus The DtoActionStatus to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoActionStatusType(xmlTextWriterPtr writer, struct Grisu_dto_dtoActionStatus *_dtoActionStatus) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoActionStatus->handle != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "handle", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}handle. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}handle...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoActionStatus->handle));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}handle. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}handle. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoActionStatus->lastUpdate != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "lastUpdate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}lastUpdate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}dateTime for attribute {}lastUpdate...\n");
#endif
    status = xmlTextWriterWriteXsDateTimeType(writer, (_dtoActionStatus->lastUpdate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}dateTime for attribute {}lastUpdate. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}lastUpdate. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (1) { //always write the primitive attribute
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "failed", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}failed. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}failed...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_dtoActionStatus->failed));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}failed. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}failed. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (1) { //always write the primitive attribute
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "totalElements", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}totalElements. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for attribute {}totalElements...\n");
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoActionStatus->totalElements));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for attribute {}totalElements. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}totalElements. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (1) { //always write the primitive attribute
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "finished", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}finished. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}finished...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_dtoActionStatus->finished));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}finished. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}finished. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "currentElements", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}currentElements. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}currentElements...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoActionStatus->currentElements));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}currentElements. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}currentElements. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _dtoActionStatus->_sizeof_log; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "log", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}log. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoLogItem for element {}log...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoLogItemType(writer, &(_dtoActionStatus->log[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoLogItem for element {}log. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}log. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoActionStatus.
 *
 * @param _dtoActionStatus The DtoActionStatus to free.
 */
static void freeDtoDtoActionStatusType(struct Grisu_dto_dtoActionStatus *_dtoActionStatus) {
  int i;
  if (_dtoActionStatus->handle != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor handle of type Grisu_dto_dtoActionStatus...\n");
#endif
    freeXsStringType(_dtoActionStatus->handle);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor handle of type Grisu_dto_dtoActionStatus...\n");
#endif
    free(_dtoActionStatus->handle);
  }
  if (_dtoActionStatus->lastUpdate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor lastUpdate of type Grisu_dto_dtoActionStatus...\n");
#endif
    freeXsDateTimeType(_dtoActionStatus->lastUpdate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor lastUpdate of type Grisu_dto_dtoActionStatus...\n");
#endif
    free(_dtoActionStatus->lastUpdate);
  }
  if (_dtoActionStatus->log != NULL) {
    for (i = 0; i < _dtoActionStatus->_sizeof_log; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor log[%i] of type Grisu_dto_dtoActionStatus...\n", i);
#endif
      freeDtoDtoLogItemType(&(_dtoActionStatus->log[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor log of type Grisu_dto_dtoActionStatus...\n");
#endif
    free(_dtoActionStatus->log);
  }
}
#endif /* DEF_Grisu_dto_dtoActionStatus_M */
#ifndef DEF_Grisu_dto_dtoApplicationDetail_M
#define DEF_Grisu_dto_dtoApplicationDetail_M

/**
 * Reads a DtoApplicationDetail element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}applicationdetail", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoApplicationDetail, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationDetail *xml_read_Grisu_dto_dtoApplicationDetail(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoApplicationdetailElement(reader);
}

/**
 * Writes a DtoApplicationDetail to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetail".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetail The DtoApplicationDetail to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoApplicationDetail(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail) {
  return xmlTextWriterWriteDtoApplicationdetailElementNS(writer, _dtoApplicationDetail, 1);
}

/**
 * Frees a DtoApplicationDetail.
 *
 * @param _dtoApplicationDetail The DtoApplicationDetail to free.
 */
void free_Grisu_dto_dtoApplicationDetail(struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail) {
  freeDtoDtoApplicationDetailType(_dtoApplicationDetail);
  free(_dtoApplicationDetail);
}

/**
 * Reads a DtoApplicationDetail element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}applicationdetail", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoApplicationDetail, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationDetail *xmlTextReaderReadDtoApplicationdetailElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "applicationdetail", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}applicationdetail.\n");
#endif
    _dtoApplicationDetail = xmlTextReaderReadDtoDtoApplicationDetailType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoApplicationDetail == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}applicationdetail failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}applicationdetail failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoApplicationDetail;
}

/**
 * Writes a DtoApplicationDetail to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetail".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetail The DtoApplicationDetail to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoApplicationdetailElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail) {
  return xmlTextWriterWriteDtoApplicationdetailElementNS(writer, _dtoApplicationDetail, 0);
}

/**
 * Writes a DtoApplicationDetail to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetail".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetail The DtoApplicationDetail to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoApplicationdetailElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "applicationdetail", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}applicationdetail. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}applicationdetail...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoApplicationDetail for root element {http://api.grisu.arcs.org.au/dto}applicationdetail...\n");
#endif
  status = xmlTextWriterWriteDtoDtoApplicationDetailType(writer, _dtoApplicationDetail);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}applicationdetail. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}applicationdetail. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoApplicationDetail.
 *
 * @param _dtoApplicationDetail The DtoApplicationDetail whose children are to be free.
 */
static void freeDtoApplicationdetailElement(struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail) {
  freeDtoDtoApplicationDetailType(_dtoApplicationDetail);
}

/**
 * Reads a DtoApplicationDetail from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoApplicationDetail, or NULL in case of error.
 */
static struct Grisu_dto_dtoApplicationDetail *xmlTextReaderReadDtoDtoApplicationDetailType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail = calloc(1, sizeof(struct Grisu_dto_dtoApplicationDetail));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "key", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}key...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}key of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoApplicationDetailType(_dtoApplicationDetail);
          free(_dtoApplicationDetail);
          return NULL;
        }
        _dtoApplicationDetail->key = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoApplicationDetailType(_dtoApplicationDetail);
      free(_dtoApplicationDetail);
      return NULL;
    }
  }

  if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from element value...\n");
#endif
    _child_accessor = xmlTextReaderReadXsStringType(reader);
    if (_child_accessor == NULL) {
      //panic: unable to return the value for some reason.
#if DEBUG_ENUNCIATE
      printf("Failed to read value of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
      freeDtoDtoApplicationDetailType(_dtoApplicationDetail);
      free(_dtoApplicationDetail);
      return NULL;
    }
    _dtoApplicationDetail->value = ((xmlChar*)_child_accessor);
  }
  else {
    _dtoApplicationDetail->value = BAD_CAST "";
  }


  return _dtoApplicationDetail;
}

/**
 * Writes a DtoApplicationDetail to XML.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetail The DtoApplicationDetail to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoApplicationDetailType(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoApplicationDetail->key != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "key", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}key. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}key...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoApplicationDetail->key));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}key. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}key. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoApplicationDetail->value != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element value...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoApplicationDetail->value));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element value. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoApplicationDetail.
 *
 * @param _dtoApplicationDetail The DtoApplicationDetail to free.
 */
static void freeDtoDtoApplicationDetailType(struct Grisu_dto_dtoApplicationDetail *_dtoApplicationDetail) {
  int i;
  if (_dtoApplicationDetail->key != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor key of type Grisu_dto_dtoApplicationDetail...\n");
#endif
    freeXsStringType(_dtoApplicationDetail->key);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor key of type Grisu_dto_dtoApplicationDetail...\n");
#endif
    free(_dtoApplicationDetail->key);
  }
  if (_dtoApplicationDetail->value != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor value of type Grisu_dto_dtoApplicationDetail...\n");
#endif
    freeXsStringType(_dtoApplicationDetail->value);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor value of type Grisu_dto_dtoApplicationDetail...\n");
#endif
    free(_dtoApplicationDetail->value);
  }
}
#endif /* DEF_Grisu_dto_dtoApplicationDetail_M */
#ifndef DEF_Grisu_dto_dtoApplicationDetails_M
#define DEF_Grisu_dto_dtoApplicationDetails_M

/**
 * Reads a DtoApplicationDetails element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}applicationdetails", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoApplicationDetails, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationDetails *xml_read_Grisu_dto_dtoApplicationDetails(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoApplicationdetailsElement(reader);
}

/**
 * Writes a DtoApplicationDetails to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetails".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetails The DtoApplicationDetails to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoApplicationDetails(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails) {
  return xmlTextWriterWriteDtoApplicationdetailsElementNS(writer, _dtoApplicationDetails, 1);
}

/**
 * Frees a DtoApplicationDetails.
 *
 * @param _dtoApplicationDetails The DtoApplicationDetails to free.
 */
void free_Grisu_dto_dtoApplicationDetails(struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails) {
  freeDtoDtoApplicationDetailsType(_dtoApplicationDetails);
  free(_dtoApplicationDetails);
}

/**
 * Reads a DtoApplicationDetails element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}applicationdetails", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoApplicationDetails, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationDetails *xmlTextReaderReadDtoApplicationdetailsElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "applicationdetails", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}applicationdetails.\n");
#endif
    _dtoApplicationDetails = xmlTextReaderReadDtoDtoApplicationDetailsType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoApplicationDetails == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}applicationdetails failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}applicationdetails failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoApplicationDetails;
}

/**
 * Writes a DtoApplicationDetails to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetails".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetails The DtoApplicationDetails to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoApplicationdetailsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails) {
  return xmlTextWriterWriteDtoApplicationdetailsElementNS(writer, _dtoApplicationDetails, 0);
}

/**
 * Writes a DtoApplicationDetails to XML under element name "{http://api.grisu.arcs.org.au/dto}applicationdetails".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetails The DtoApplicationDetails to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoApplicationdetailsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "applicationdetails", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}applicationdetails. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}applicationdetails...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoApplicationDetails for root element {http://api.grisu.arcs.org.au/dto}applicationdetails...\n");
#endif
  status = xmlTextWriterWriteDtoDtoApplicationDetailsType(writer, _dtoApplicationDetails);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}applicationdetails. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}applicationdetails. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoApplicationDetails.
 *
 * @param _dtoApplicationDetails The DtoApplicationDetails whose children are to be free.
 */
static void freeDtoApplicationdetailsElement(struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails) {
  freeDtoDtoApplicationDetailsType(_dtoApplicationDetails);
}

/**
 * Reads a DtoApplicationDetails from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoApplicationDetails, or NULL in case of error.
 */
static struct Grisu_dto_dtoApplicationDetails *xmlTextReaderReadDtoDtoApplicationDetailsType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails = calloc(1, sizeof(struct Grisu_dto_dtoApplicationDetails));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "applicationName", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}applicationName...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}applicationName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoApplicationDetailsType(_dtoApplicationDetails);
          free(_dtoApplicationDetails);
          return NULL;
        }
        _dtoApplicationDetails->applicationName = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoApplicationDetailsType(_dtoApplicationDetails);
      free(_dtoApplicationDetails);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoApplicationDetailsType(_dtoApplicationDetails);
        free(_dtoApplicationDetails);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "detail", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}detail of type {http://api.grisu.arcs.org.au/dto}dtoApplicationDetail.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoApplicationDetailType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}detail of type {http://api.grisu.arcs.org.au/dto}dtoApplicationDetail.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoApplicationDetailsType(_dtoApplicationDetails);
          free(_dtoApplicationDetails);
          return NULL;
        }

        _dtoApplicationDetails->details = realloc(_dtoApplicationDetails->details, (_dtoApplicationDetails->_sizeof_details + 1) * sizeof(struct Grisu_dto_dtoApplicationDetail));
        memcpy(&(_dtoApplicationDetails->details[_dtoApplicationDetails->_sizeof_details++]), _child_accessor, sizeof(struct Grisu_dto_dtoApplicationDetail));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoApplicationDetails.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoApplicationDetails. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoApplicationDetails;
}

/**
 * Writes a DtoApplicationDetails to XML.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationDetails The DtoApplicationDetails to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoApplicationDetailsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoApplicationDetails->applicationName != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "applicationName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}applicationName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}applicationName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoApplicationDetails->applicationName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}applicationName. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}applicationName. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _dtoApplicationDetails->_sizeof_details; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "detail", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}detail. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoApplicationDetail for element {}detail...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoApplicationDetailType(writer, &(_dtoApplicationDetails->details[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoApplicationDetail for element {}detail. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}detail. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoApplicationDetails.
 *
 * @param _dtoApplicationDetails The DtoApplicationDetails to free.
 */
static void freeDtoDtoApplicationDetailsType(struct Grisu_dto_dtoApplicationDetails *_dtoApplicationDetails) {
  int i;
  if (_dtoApplicationDetails->applicationName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor applicationName of type Grisu_dto_dtoApplicationDetails...\n");
#endif
    freeXsStringType(_dtoApplicationDetails->applicationName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor applicationName of type Grisu_dto_dtoApplicationDetails...\n");
#endif
    free(_dtoApplicationDetails->applicationName);
  }
  if (_dtoApplicationDetails->details != NULL) {
    for (i = 0; i < _dtoApplicationDetails->_sizeof_details; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor details[%i] of type Grisu_dto_dtoApplicationDetails...\n", i);
#endif
      freeDtoDtoApplicationDetailType(&(_dtoApplicationDetails->details[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor details of type Grisu_dto_dtoApplicationDetails...\n");
#endif
    free(_dtoApplicationDetails->details);
  }
}
#endif /* DEF_Grisu_dto_dtoApplicationDetails_M */
#ifndef DEF_Grisu_dto_dtoApplicationInfo_M
#define DEF_Grisu_dto_dtoApplicationInfo_M

/**
 * Reads a DtoApplicationInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}application", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoApplicationInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationInfo *xml_read_Grisu_dto_dtoApplicationInfo(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoApplicationElement(reader);
}

/**
 * Writes a DtoApplicationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}application".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationInfo The DtoApplicationInfo to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoApplicationInfo(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo) {
  return xmlTextWriterWriteDtoApplicationElementNS(writer, _dtoApplicationInfo, 1);
}

/**
 * Frees a DtoApplicationInfo.
 *
 * @param _dtoApplicationInfo The DtoApplicationInfo to free.
 */
void free_Grisu_dto_dtoApplicationInfo(struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo) {
  freeDtoDtoApplicationInfoType(_dtoApplicationInfo);
  free(_dtoApplicationInfo);
}

/**
 * Reads a DtoApplicationInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}application", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoApplicationInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoApplicationInfo *xmlTextReaderReadDtoApplicationElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "application", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}application.\n");
#endif
    _dtoApplicationInfo = xmlTextReaderReadDtoDtoApplicationInfoType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoApplicationInfo == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}application failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}application failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoApplicationInfo;
}

/**
 * Writes a DtoApplicationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}application".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationInfo The DtoApplicationInfo to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoApplicationElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo) {
  return xmlTextWriterWriteDtoApplicationElementNS(writer, _dtoApplicationInfo, 0);
}

/**
 * Writes a DtoApplicationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}application".
 *
 * @param writer The XML writer.
 * @param _dtoApplicationInfo The DtoApplicationInfo to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoApplicationElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "application", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}application. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}application...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoApplicationInfo for root element {http://api.grisu.arcs.org.au/dto}application...\n");
#endif
  status = xmlTextWriterWriteDtoDtoApplicationInfoType(writer, _dtoApplicationInfo);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}application. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}application. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoApplicationInfo.
 *
 * @param _dtoApplicationInfo The DtoApplicationInfo whose children are to be free.
 */
static void freeDtoApplicationElement(struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo) {
  freeDtoDtoApplicationInfoType(_dtoApplicationInfo);
}

/**
 * Reads a DtoApplicationInfo from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoApplicationInfo, or NULL in case of error.
 */
static struct Grisu_dto_dtoApplicationInfo *xmlTextReaderReadDtoDtoApplicationInfoType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo = calloc(1, sizeof(struct Grisu_dto_dtoApplicationInfo));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "applicationName", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}applicationName...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}applicationName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoApplicationInfoType(_dtoApplicationInfo);
          free(_dtoApplicationInfo);
          return NULL;
        }
        _dtoApplicationInfo->name = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoApplicationInfoType(_dtoApplicationInfo);
      free(_dtoApplicationInfo);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoApplicationInfoType(_dtoApplicationInfo);
        free(_dtoApplicationInfo);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "version", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}version of type {http://api.grisu.arcs.org.au/dto}dtoVersionInfo.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoVersionInfoType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}version of type {http://api.grisu.arcs.org.au/dto}dtoVersionInfo.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoApplicationInfoType(_dtoApplicationInfo);
          free(_dtoApplicationInfo);
          return NULL;
        }

        _dtoApplicationInfo->allVersions = realloc(_dtoApplicationInfo->allVersions, (_dtoApplicationInfo->_sizeof_allVersions + 1) * sizeof(struct Grisu_dto_dtoVersionInfo));
        memcpy(&(_dtoApplicationInfo->allVersions[_dtoApplicationInfo->_sizeof_allVersions++]), _child_accessor, sizeof(struct Grisu_dto_dtoVersionInfo));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoApplicationInfo.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoApplicationInfo. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoApplicationInfo;
}

/**
 * Writes a DtoApplicationInfo to XML.
 *
 * @param writer The XML writer.
 * @param _dtoApplicationInfo The DtoApplicationInfo to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoApplicationInfoType(xmlTextWriterPtr writer, struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoApplicationInfo->name != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "applicationName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}applicationName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}applicationName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoApplicationInfo->name));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}applicationName. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}applicationName. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _dtoApplicationInfo->_sizeof_allVersions; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "version", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}version. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoVersionInfo for element {}version...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoVersionInfoType(writer, &(_dtoApplicationInfo->allVersions[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoVersionInfo for element {}version. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}version. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoApplicationInfo.
 *
 * @param _dtoApplicationInfo The DtoApplicationInfo to free.
 */
static void freeDtoDtoApplicationInfoType(struct Grisu_dto_dtoApplicationInfo *_dtoApplicationInfo) {
  int i;
  if (_dtoApplicationInfo->name != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor name of type Grisu_dto_dtoApplicationInfo...\n");
#endif
    freeXsStringType(_dtoApplicationInfo->name);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor name of type Grisu_dto_dtoApplicationInfo...\n");
#endif
    free(_dtoApplicationInfo->name);
  }
  if (_dtoApplicationInfo->allVersions != NULL) {
    for (i = 0; i < _dtoApplicationInfo->_sizeof_allVersions; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor allVersions[%i] of type Grisu_dto_dtoApplicationInfo...\n", i);
#endif
      freeDtoDtoVersionInfoType(&(_dtoApplicationInfo->allVersions[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor allVersions of type Grisu_dto_dtoApplicationInfo...\n");
#endif
    free(_dtoApplicationInfo->allVersions);
  }
}
#endif /* DEF_Grisu_dto_dtoApplicationInfo_M */
#ifndef DEF_Grisu_dto_dtoBatchJob_M
#define DEF_Grisu_dto_dtoBatchJob_M

/**
 * Reads a DtoBatchJob element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}multiPartJob", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoBatchJob, or NULL in case of error.
 */
struct Grisu_dto_dtoBatchJob *xml_read_Grisu_dto_dtoBatchJob(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoMultiPartJobElement(reader);
}

/**
 * Writes a DtoBatchJob to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJob".
 *
 * @param writer The XML writer.
 * @param _dtoBatchJob The DtoBatchJob to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoBatchJob(xmlTextWriterPtr writer, struct Grisu_dto_dtoBatchJob *_dtoBatchJob) {
  return xmlTextWriterWriteDtoMultiPartJobElementNS(writer, _dtoBatchJob, 1);
}

/**
 * Frees a DtoBatchJob.
 *
 * @param _dtoBatchJob The DtoBatchJob to free.
 */
void free_Grisu_dto_dtoBatchJob(struct Grisu_dto_dtoBatchJob *_dtoBatchJob) {
  freeDtoDtoBatchJobType(_dtoBatchJob);
  free(_dtoBatchJob);
}

/**
 * Reads a DtoBatchJob element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}multiPartJob", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoBatchJob, or NULL in case of error.
 */
struct Grisu_dto_dtoBatchJob *xmlTextReaderReadDtoMultiPartJobElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoBatchJob *_dtoBatchJob = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "multiPartJob", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}multiPartJob.\n");
#endif
    _dtoBatchJob = xmlTextReaderReadDtoDtoBatchJobType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoBatchJob == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}multiPartJob failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}multiPartJob failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoBatchJob;
}

/**
 * Writes a DtoBatchJob to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJob".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoBatchJob The DtoBatchJob to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoMultiPartJobElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoBatchJob *_dtoBatchJob) {
  return xmlTextWriterWriteDtoMultiPartJobElementNS(writer, _dtoBatchJob, 0);
}

/**
 * Writes a DtoBatchJob to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJob".
 *
 * @param writer The XML writer.
 * @param _dtoBatchJob The DtoBatchJob to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoMultiPartJobElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoBatchJob *_dtoBatchJob, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "multiPartJob", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}multiPartJob. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}multiPartJob...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoBatchJob for root element {http://api.grisu.arcs.org.au/dto}multiPartJob...\n");
#endif
  status = xmlTextWriterWriteDtoDtoBatchJobType(writer, _dtoBatchJob);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}multiPartJob. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}multiPartJob. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoBatchJob.
 *
 * @param _dtoBatchJob The DtoBatchJob whose children are to be free.
 */
static void freeDtoMultiPartJobElement(struct Grisu_dto_dtoBatchJob *_dtoBatchJob) {
  freeDtoDtoBatchJobType(_dtoBatchJob);
}

/**
 * Reads a DtoBatchJob from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoBatchJob, or NULL in case of error.
 */
static struct Grisu_dto_dtoBatchJob *xmlTextReaderReadDtoDtoBatchJobType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoBatchJob *_dtoBatchJob = calloc(1, sizeof(struct Grisu_dto_dtoBatchJob));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "finished", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}boolean from attribute {}finished...\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}finished of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          freeDtoDtoBatchJobType(_dtoBatchJob);
          free(_dtoBatchJob);
          return NULL;
        }
        _dtoBatchJob->finished = *((int*)_child_accessor);
        freeXsBooleanType((int*) _child_accessor);
        free(_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoBatchJobType(_dtoBatchJob);
      free(_dtoBatchJob);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoBatchJobType(_dtoBatchJob);
        free(_dtoBatchJob);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "batchJobname", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}batchJobname of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}batchJobname of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoBatchJobType(_dtoBatchJob);
          free(_dtoBatchJob);
          return NULL;
        }

        _dtoBatchJob->batchJobname = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "failedJob", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}failedJob of type {http://api.grisu.arcs.org.au/dto}dtoJobs.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoJobsType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}failedJob of type {http://api.grisu.arcs.org.au/dto}dtoJobs.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoBatchJobType(_dtoBatchJob);
          free(_dtoBatchJob);
          return NULL;
        }

        _dtoBatchJob->failedJobs = ((struct Grisu_dto_dtoJobs*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "jobs", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}jobs of type {http://api.grisu.arcs.org.au/dto}dtoJobs.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoJobsType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}jobs of type {http://api.grisu.arcs.org.au/dto}dtoJobs.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoBatchJobType(_dtoBatchJob);
          free(_dtoBatchJob);
          return NULL;
        }

        _dtoBatchJob->jobs = ((struct Grisu_dto_dtoJobs*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "logMessages", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}logMessages of type {http://api.grisu.arcs.org.au/dto}dtoLogMessages.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoLogMessagesType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}logMessages of type {http://api.grisu.arcs.org.au/dto}dtoLogMessages.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoBatchJobType(_dtoBatchJob);
          free(_dtoBatchJob);
          return NULL;
        }

        _dtoBatchJob->messages = ((struct Grisu_dto_dtoLogMessages*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "jobproperty", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}jobproperty of type {http://api.grisu.arcs.org.au/dto}dtoJobProperty.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoJobPropertyType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}jobproperty of type {http://api.grisu.arcs.org.au/dto}dtoJobProperty.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoBatchJobType(_dtoBatchJob);
          free(_dtoBatchJob);
          return NULL;
        }

        _dtoBatchJob->properties = realloc(_dtoBatchJob->properties, (_dtoBatchJob->_sizeof_properties + 1) * sizeof(struct Grisu_dto_dtoJobProperty));
        memcpy(&(_dtoBatchJob->properties[_dtoBatchJob->_sizeof_properties++]), _child_accessor, sizeof(struct Grisu_dto_dtoJobProperty));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "status", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}status of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}status of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoBatchJobType(_dtoBatchJob);
          free(_dtoBatchJob);
          return NULL;
        }

        _dtoBatchJob->status = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "fqan", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}fqan of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}fqan of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoBatchJobType(_dtoBatchJob);
          free(_dtoBatchJob);
          return NULL;
        }

        _dtoBatchJob->submissionFqan = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoBatchJob.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoBatchJob. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoBatchJob;
}

/**
 * Writes a DtoBatchJob to XML.
 *
 * @param writer The XML writer.
 * @param _dtoBatchJob The DtoBatchJob to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoBatchJobType(xmlTextWriterPtr writer, struct Grisu_dto_dtoBatchJob *_dtoBatchJob) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (1) { //always write the primitive attribute
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "finished", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}finished. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}finished...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_dtoBatchJob->finished));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}finished. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}finished. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_dtoBatchJob->batchJobname != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "batchJobname", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}batchJobname. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}batchJobname...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoBatchJob->batchJobname));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}batchJobname. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}batchJobname. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_dtoBatchJob->failedJobs != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "failedJob", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}failedJob. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoJobs for element {}failedJob...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoJobsType(writer, (_dtoBatchJob->failedJobs));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoJobs for element {}failedJob. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}failedJob. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_dtoBatchJob->jobs != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "jobs", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}jobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoJobs for element {}jobs...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoJobsType(writer, (_dtoBatchJob->jobs));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoJobs for element {}jobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}jobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_dtoBatchJob->messages != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "logMessages", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}logMessages. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoLogMessages for element {}logMessages...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoLogMessagesType(writer, (_dtoBatchJob->messages));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoLogMessages for element {}logMessages. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}logMessages. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _dtoBatchJob->_sizeof_properties; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "jobproperty", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}jobproperty. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoJobProperty for element {}jobproperty...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoJobPropertyType(writer, &(_dtoBatchJob->properties[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoJobProperty for element {}jobproperty. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}jobproperty. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "status", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}status. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}status...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoBatchJob->status));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}status. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}status. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_dtoBatchJob->submissionFqan != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "fqan", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}fqan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}fqan...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoBatchJob->submissionFqan));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}fqan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}fqan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoBatchJob.
 *
 * @param _dtoBatchJob The DtoBatchJob to free.
 */
static void freeDtoDtoBatchJobType(struct Grisu_dto_dtoBatchJob *_dtoBatchJob) {
  int i;
  if (_dtoBatchJob->batchJobname != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor batchJobname of type Grisu_dto_dtoBatchJob...\n");
#endif
    freeXsStringType(_dtoBatchJob->batchJobname);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor batchJobname of type Grisu_dto_dtoBatchJob...\n");
#endif
    free(_dtoBatchJob->batchJobname);
  }
  if (_dtoBatchJob->failedJobs != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor failedJobs of type Grisu_dto_dtoBatchJob...\n");
#endif
    freeDtoDtoJobsType(_dtoBatchJob->failedJobs);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor failedJobs of type Grisu_dto_dtoBatchJob...\n");
#endif
    free(_dtoBatchJob->failedJobs);
  }
  if (_dtoBatchJob->jobs != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor jobs of type Grisu_dto_dtoBatchJob...\n");
#endif
    freeDtoDtoJobsType(_dtoBatchJob->jobs);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor jobs of type Grisu_dto_dtoBatchJob...\n");
#endif
    free(_dtoBatchJob->jobs);
  }
  if (_dtoBatchJob->messages != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor messages of type Grisu_dto_dtoBatchJob...\n");
#endif
    freeDtoDtoLogMessagesType(_dtoBatchJob->messages);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor messages of type Grisu_dto_dtoBatchJob...\n");
#endif
    free(_dtoBatchJob->messages);
  }
  if (_dtoBatchJob->properties != NULL) {
    for (i = 0; i < _dtoBatchJob->_sizeof_properties; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor properties[%i] of type Grisu_dto_dtoBatchJob...\n", i);
#endif
      freeDtoDtoJobPropertyType(&(_dtoBatchJob->properties[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor properties of type Grisu_dto_dtoBatchJob...\n");
#endif
    free(_dtoBatchJob->properties);
  }
  if (_dtoBatchJob->submissionFqan != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor submissionFqan of type Grisu_dto_dtoBatchJob...\n");
#endif
    freeXsStringType(_dtoBatchJob->submissionFqan);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor submissionFqan of type Grisu_dto_dtoBatchJob...\n");
#endif
    free(_dtoBatchJob->submissionFqan);
  }
}
#endif /* DEF_Grisu_dto_dtoBatchJob_M */
#ifndef DEF_Grisu_dto_dtoDataLocation_M
#define DEF_Grisu_dto_dtoDataLocation_M

/**
 * Reads a DtoDataLocation element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}datalocation", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoDataLocation, or NULL in case of error.
 */
struct Grisu_dto_dtoDataLocation *xml_read_Grisu_dto_dtoDataLocation(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoDatalocationElement(reader);
}

/**
 * Writes a DtoDataLocation to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocation".
 *
 * @param writer The XML writer.
 * @param _dtoDataLocation The DtoDataLocation to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoDataLocation(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocation *_dtoDataLocation) {
  return xmlTextWriterWriteDtoDatalocationElementNS(writer, _dtoDataLocation, 1);
}

/**
 * Frees a DtoDataLocation.
 *
 * @param _dtoDataLocation The DtoDataLocation to free.
 */
void free_Grisu_dto_dtoDataLocation(struct Grisu_dto_dtoDataLocation *_dtoDataLocation) {
  freeDtoDtoDataLocationType(_dtoDataLocation);
  free(_dtoDataLocation);
}

/**
 * Reads a DtoDataLocation element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}datalocation", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoDataLocation, or NULL in case of error.
 */
struct Grisu_dto_dtoDataLocation *xmlTextReaderReadDtoDatalocationElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoDataLocation *_dtoDataLocation = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "datalocation", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}datalocation.\n");
#endif
    _dtoDataLocation = xmlTextReaderReadDtoDtoDataLocationType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoDataLocation == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}datalocation failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}datalocation failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoDataLocation;
}

/**
 * Writes a DtoDataLocation to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocation".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoDataLocation The DtoDataLocation to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoDatalocationElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocation *_dtoDataLocation) {
  return xmlTextWriterWriteDtoDatalocationElementNS(writer, _dtoDataLocation, 0);
}

/**
 * Writes a DtoDataLocation to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocation".
 *
 * @param writer The XML writer.
 * @param _dtoDataLocation The DtoDataLocation to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoDatalocationElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocation *_dtoDataLocation, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "datalocation", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}datalocation. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}datalocation...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoDataLocation for root element {http://api.grisu.arcs.org.au/dto}datalocation...\n");
#endif
  status = xmlTextWriterWriteDtoDtoDataLocationType(writer, _dtoDataLocation);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}datalocation. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}datalocation. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoDataLocation.
 *
 * @param _dtoDataLocation The DtoDataLocation whose children are to be free.
 */
static void freeDtoDatalocationElement(struct Grisu_dto_dtoDataLocation *_dtoDataLocation) {
  freeDtoDtoDataLocationType(_dtoDataLocation);
}

/**
 * Reads a DtoDataLocation from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoDataLocation, or NULL in case of error.
 */
static struct Grisu_dto_dtoDataLocation *xmlTextReaderReadDtoDtoDataLocationType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoDataLocation *_dtoDataLocation = calloc(1, sizeof(struct Grisu_dto_dtoDataLocation));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "rooturl", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}rooturl...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}rooturl of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoDataLocationType(_dtoDataLocation);
          free(_dtoDataLocation);
          return NULL;
        }
        _dtoDataLocation->rooturl = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoDataLocationType(_dtoDataLocation);
      free(_dtoDataLocation);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoDataLocationType(_dtoDataLocation);
        free(_dtoDataLocation);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "fqan", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}fqan of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}fqan of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoDataLocationType(_dtoDataLocation);
          free(_dtoDataLocation);
          return NULL;
        }

        _dtoDataLocation->fqan = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "path", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}path of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}path of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoDataLocationType(_dtoDataLocation);
          free(_dtoDataLocation);
          return NULL;
        }

        _dtoDataLocation->paths = realloc(_dtoDataLocation->paths, (_dtoDataLocation->_sizeof_paths + 1) * sizeof(xmlChar));
        memcpy(&(_dtoDataLocation->paths[_dtoDataLocation->_sizeof_paths++]), _child_accessor, sizeof(xmlChar));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoDataLocation.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoDataLocation. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoDataLocation;
}

/**
 * Writes a DtoDataLocation to XML.
 *
 * @param writer The XML writer.
 * @param _dtoDataLocation The DtoDataLocation to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoDataLocationType(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocation *_dtoDataLocation) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoDataLocation->rooturl != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "rooturl", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}rooturl. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}rooturl...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoDataLocation->rooturl));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}rooturl. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}rooturl. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_dtoDataLocation->fqan != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "fqan", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}fqan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}fqan...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoDataLocation->fqan));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}fqan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}fqan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _dtoDataLocation->_sizeof_paths; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "path", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}path. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}path...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, &(_dtoDataLocation->paths[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}path. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}path. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoDataLocation.
 *
 * @param _dtoDataLocation The DtoDataLocation to free.
 */
static void freeDtoDtoDataLocationType(struct Grisu_dto_dtoDataLocation *_dtoDataLocation) {
  int i;
  if (_dtoDataLocation->rooturl != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor rooturl of type Grisu_dto_dtoDataLocation...\n");
#endif
    freeXsStringType(_dtoDataLocation->rooturl);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor rooturl of type Grisu_dto_dtoDataLocation...\n");
#endif
    free(_dtoDataLocation->rooturl);
  }
  if (_dtoDataLocation->fqan != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor fqan of type Grisu_dto_dtoDataLocation...\n");
#endif
    freeXsStringType(_dtoDataLocation->fqan);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor fqan of type Grisu_dto_dtoDataLocation...\n");
#endif
    free(_dtoDataLocation->fqan);
  }
  if (_dtoDataLocation->paths != NULL) {
    for (i = 0; i < _dtoDataLocation->_sizeof_paths; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor paths[%i] of type Grisu_dto_dtoDataLocation...\n", i);
#endif
      freeXsStringType(&(_dtoDataLocation->paths[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor paths of type Grisu_dto_dtoDataLocation...\n");
#endif
    free(_dtoDataLocation->paths);
  }
}
#endif /* DEF_Grisu_dto_dtoDataLocation_M */
#ifndef DEF_Grisu_dto_dtoDataLocations_M
#define DEF_Grisu_dto_dtoDataLocations_M

/**
 * Reads a DtoDataLocations element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}datalocations", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoDataLocations, or NULL in case of error.
 */
struct Grisu_dto_dtoDataLocations *xml_read_Grisu_dto_dtoDataLocations(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoDatalocationsElement(reader);
}

/**
 * Writes a DtoDataLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocations".
 *
 * @param writer The XML writer.
 * @param _dtoDataLocations The DtoDataLocations to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoDataLocations(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocations *_dtoDataLocations) {
  return xmlTextWriterWriteDtoDatalocationsElementNS(writer, _dtoDataLocations, 1);
}

/**
 * Frees a DtoDataLocations.
 *
 * @param _dtoDataLocations The DtoDataLocations to free.
 */
void free_Grisu_dto_dtoDataLocations(struct Grisu_dto_dtoDataLocations *_dtoDataLocations) {
  freeDtoDtoDataLocationsType(_dtoDataLocations);
  free(_dtoDataLocations);
}

/**
 * Reads a DtoDataLocations element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}datalocations", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoDataLocations, or NULL in case of error.
 */
struct Grisu_dto_dtoDataLocations *xmlTextReaderReadDtoDatalocationsElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoDataLocations *_dtoDataLocations = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "datalocations", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}datalocations.\n");
#endif
    _dtoDataLocations = xmlTextReaderReadDtoDtoDataLocationsType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoDataLocations == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}datalocations failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}datalocations failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoDataLocations;
}

/**
 * Writes a DtoDataLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocations".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoDataLocations The DtoDataLocations to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoDatalocationsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocations *_dtoDataLocations) {
  return xmlTextWriterWriteDtoDatalocationsElementNS(writer, _dtoDataLocations, 0);
}

/**
 * Writes a DtoDataLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}datalocations".
 *
 * @param writer The XML writer.
 * @param _dtoDataLocations The DtoDataLocations to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoDatalocationsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocations *_dtoDataLocations, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "datalocations", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}datalocations. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}datalocations...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoDataLocations for root element {http://api.grisu.arcs.org.au/dto}datalocations...\n");
#endif
  status = xmlTextWriterWriteDtoDtoDataLocationsType(writer, _dtoDataLocations);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}datalocations. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}datalocations. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoDataLocations.
 *
 * @param _dtoDataLocations The DtoDataLocations whose children are to be free.
 */
static void freeDtoDatalocationsElement(struct Grisu_dto_dtoDataLocations *_dtoDataLocations) {
  freeDtoDtoDataLocationsType(_dtoDataLocations);
}

/**
 * Reads a DtoDataLocations from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoDataLocations, or NULL in case of error.
 */
static struct Grisu_dto_dtoDataLocations *xmlTextReaderReadDtoDtoDataLocationsType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoDataLocations *_dtoDataLocations = calloc(1, sizeof(struct Grisu_dto_dtoDataLocations));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoDataLocationsType(_dtoDataLocations);
        free(_dtoDataLocations);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "datalocation", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}datalocation of type {http://api.grisu.arcs.org.au/dto}dtoDataLocation.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoDataLocationType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}datalocation of type {http://api.grisu.arcs.org.au/dto}dtoDataLocation.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoDataLocationsType(_dtoDataLocations);
          free(_dtoDataLocations);
          return NULL;
        }

        _dtoDataLocations->dataLocations = realloc(_dtoDataLocations->dataLocations, (_dtoDataLocations->_sizeof_dataLocations + 1) * sizeof(struct Grisu_dto_dtoDataLocation));
        memcpy(&(_dtoDataLocations->dataLocations[_dtoDataLocations->_sizeof_dataLocations++]), _child_accessor, sizeof(struct Grisu_dto_dtoDataLocation));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoDataLocations.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoDataLocations. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoDataLocations;
}

/**
 * Writes a DtoDataLocations to XML.
 *
 * @param writer The XML writer.
 * @param _dtoDataLocations The DtoDataLocations to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoDataLocationsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoDataLocations *_dtoDataLocations) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _dtoDataLocations->_sizeof_dataLocations; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "datalocation", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}datalocation. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoDataLocation for element {}datalocation...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoDataLocationType(writer, &(_dtoDataLocations->dataLocations[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoDataLocation for element {}datalocation. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}datalocation. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoDataLocations.
 *
 * @param _dtoDataLocations The DtoDataLocations to free.
 */
static void freeDtoDtoDataLocationsType(struct Grisu_dto_dtoDataLocations *_dtoDataLocations) {
  int i;
  if (_dtoDataLocations->dataLocations != NULL) {
    for (i = 0; i < _dtoDataLocations->_sizeof_dataLocations; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor dataLocations[%i] of type Grisu_dto_dtoDataLocations...\n", i);
#endif
      freeDtoDtoDataLocationType(&(_dtoDataLocations->dataLocations[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor dataLocations of type Grisu_dto_dtoDataLocations...\n");
#endif
    free(_dtoDataLocations->dataLocations);
  }
}
#endif /* DEF_Grisu_dto_dtoDataLocations_M */
#ifndef DEF_Grisu_dto_dtoFile_M
#define DEF_Grisu_dto_dtoFile_M

/**
 * Reads a DtoFile element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}file", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoFile, or NULL in case of error.
 */
struct Grisu_dto_dtoFile *xml_read_Grisu_dto_dtoFile(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoFileElement(reader);
}

/**
 * Writes a DtoFile to XML under element name "{http://api.grisu.arcs.org.au/dto}file".
 *
 * @param writer The XML writer.
 * @param _dtoFile The DtoFile to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoFile(xmlTextWriterPtr writer, struct Grisu_dto_dtoFile *_dtoFile) {
  return xmlTextWriterWriteDtoFileElementNS(writer, _dtoFile, 1);
}

/**
 * Frees a DtoFile.
 *
 * @param _dtoFile The DtoFile to free.
 */
void free_Grisu_dto_dtoFile(struct Grisu_dto_dtoFile *_dtoFile) {
  freeDtoDtoFileType(_dtoFile);
  free(_dtoFile);
}

/**
 * Reads a DtoFile element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}file", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoFile, or NULL in case of error.
 */
struct Grisu_dto_dtoFile *xmlTextReaderReadDtoFileElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoFile *_dtoFile = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "file", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}file.\n");
#endif
    _dtoFile = xmlTextReaderReadDtoDtoFileType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoFile == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}file failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}file failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoFile;
}

/**
 * Writes a DtoFile to XML under element name "{http://api.grisu.arcs.org.au/dto}file".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoFile The DtoFile to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoFileElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoFile *_dtoFile) {
  return xmlTextWriterWriteDtoFileElementNS(writer, _dtoFile, 0);
}

/**
 * Writes a DtoFile to XML under element name "{http://api.grisu.arcs.org.au/dto}file".
 *
 * @param writer The XML writer.
 * @param _dtoFile The DtoFile to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoFileElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoFile *_dtoFile, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "file", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}file. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}file...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoFile for root element {http://api.grisu.arcs.org.au/dto}file...\n");
#endif
  status = xmlTextWriterWriteDtoDtoFileType(writer, _dtoFile);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}file. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}file. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoFile.
 *
 * @param _dtoFile The DtoFile whose children are to be free.
 */
static void freeDtoFileElement(struct Grisu_dto_dtoFile *_dtoFile) {
  freeDtoDtoFileType(_dtoFile);
}

/**
 * Reads a DtoFile from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoFile, or NULL in case of error.
 */
static struct Grisu_dto_dtoFile *xmlTextReaderReadDtoDtoFileType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoFile *_dtoFile = calloc(1, sizeof(struct Grisu_dto_dtoFile));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "isFolder", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}boolean from attribute {}isFolder...\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}isFolder of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          freeDtoDtoFileType(_dtoFile);
          free(_dtoFile);
          return NULL;
        }
        _dtoFile->folder = *((int*)_child_accessor);
        freeXsBooleanType((int*) _child_accessor);
        free(_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "url", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}url...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}url of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoFileType(_dtoFile);
          free(_dtoFile);
          return NULL;
        }
        _dtoFile->rootUrl = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "name", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}name...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoFileType(_dtoFile);
          free(_dtoFile);
          return NULL;
        }
        _dtoFile->name = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoFileType(_dtoFile);
      free(_dtoFile);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoFileType(_dtoFile);
        free(_dtoFile);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "lastModified", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}lastModified of type {http://www.w3.org/2001/XMLSchema}long.\n");
#endif
        _child_accessor = xmlTextReaderReadXsLongType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}lastModified of type {http://www.w3.org/2001/XMLSchema}long.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoFileType(_dtoFile);
          free(_dtoFile);
          return NULL;
        }

        _dtoFile->lastModified = *((long*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "size", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}size of type {http://www.w3.org/2001/XMLSchema}long.\n");
#endif
        _child_accessor = xmlTextReaderReadXsLongType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}size of type {http://www.w3.org/2001/XMLSchema}long.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoFileType(_dtoFile);
          free(_dtoFile);
          return NULL;
        }

        _dtoFile->size = *((long*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoFile.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoFile. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoFile;
}

/**
 * Writes a DtoFile to XML.
 *
 * @param writer The XML writer.
 * @param _dtoFile The DtoFile to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoFileType(xmlTextWriterPtr writer, struct Grisu_dto_dtoFile *_dtoFile) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (1) { //always write the primitive attribute
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "isFolder", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}isFolder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}isFolder...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_dtoFile->folder));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}isFolder. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}isFolder. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoFile->rootUrl != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "url", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}url. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}url...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoFile->rootUrl));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}url. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}url. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoFile->name != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "name", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}name...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoFile->name));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}name. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}name. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "lastModified", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}lastModified. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}long for element {}lastModified...\n", status);
#endif
    status = xmlTextWriterWriteXsLongType(writer, &(_dtoFile->lastModified));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}long for element {}lastModified. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}lastModified. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "size", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}size. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}long for element {}size...\n", status);
#endif
    status = xmlTextWriterWriteXsLongType(writer, &(_dtoFile->size));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}long for element {}size. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}size. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoFile.
 *
 * @param _dtoFile The DtoFile to free.
 */
static void freeDtoDtoFileType(struct Grisu_dto_dtoFile *_dtoFile) {
  int i;
  if (_dtoFile->rootUrl != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor rootUrl of type Grisu_dto_dtoFile...\n");
#endif
    freeXsStringType(_dtoFile->rootUrl);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor rootUrl of type Grisu_dto_dtoFile...\n");
#endif
    free(_dtoFile->rootUrl);
  }
  if (_dtoFile->name != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor name of type Grisu_dto_dtoFile...\n");
#endif
    freeXsStringType(_dtoFile->name);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor name of type Grisu_dto_dtoFile...\n");
#endif
    free(_dtoFile->name);
  }
}
#endif /* DEF_Grisu_dto_dtoFile_M */
#ifndef DEF_Grisu_dto_dtoFolder_M
#define DEF_Grisu_dto_dtoFolder_M

/**
 * Reads a DtoFolder element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}folder", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoFolder, or NULL in case of error.
 */
struct Grisu_dto_dtoFolder *xml_read_Grisu_dto_dtoFolder(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoFolderElement(reader);
}

/**
 * Writes a DtoFolder to XML under element name "{http://api.grisu.arcs.org.au/dto}folder".
 *
 * @param writer The XML writer.
 * @param _dtoFolder The DtoFolder to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoFolder(xmlTextWriterPtr writer, struct Grisu_dto_dtoFolder *_dtoFolder) {
  return xmlTextWriterWriteDtoFolderElementNS(writer, _dtoFolder, 1);
}

/**
 * Frees a DtoFolder.
 *
 * @param _dtoFolder The DtoFolder to free.
 */
void free_Grisu_dto_dtoFolder(struct Grisu_dto_dtoFolder *_dtoFolder) {
  freeDtoDtoFolderType(_dtoFolder);
  free(_dtoFolder);
}

/**
 * Reads a DtoFolder element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}folder", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoFolder, or NULL in case of error.
 */
struct Grisu_dto_dtoFolder *xmlTextReaderReadDtoFolderElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoFolder *_dtoFolder = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "folder", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}folder.\n");
#endif
    _dtoFolder = xmlTextReaderReadDtoDtoFolderType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoFolder == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}folder failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}folder failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoFolder;
}

/**
 * Writes a DtoFolder to XML under element name "{http://api.grisu.arcs.org.au/dto}folder".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoFolder The DtoFolder to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoFolderElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoFolder *_dtoFolder) {
  return xmlTextWriterWriteDtoFolderElementNS(writer, _dtoFolder, 0);
}

/**
 * Writes a DtoFolder to XML under element name "{http://api.grisu.arcs.org.au/dto}folder".
 *
 * @param writer The XML writer.
 * @param _dtoFolder The DtoFolder to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoFolderElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoFolder *_dtoFolder, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "folder", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}folder. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}folder...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoFolder for root element {http://api.grisu.arcs.org.au/dto}folder...\n");
#endif
  status = xmlTextWriterWriteDtoDtoFolderType(writer, _dtoFolder);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}folder. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}folder. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoFolder.
 *
 * @param _dtoFolder The DtoFolder whose children are to be free.
 */
static void freeDtoFolderElement(struct Grisu_dto_dtoFolder *_dtoFolder) {
  freeDtoDtoFolderType(_dtoFolder);
}

/**
 * Reads a DtoFolder from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoFolder, or NULL in case of error.
 */
static struct Grisu_dto_dtoFolder *xmlTextReaderReadDtoDtoFolderType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoFolder *_dtoFolder = calloc(1, sizeof(struct Grisu_dto_dtoFolder));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "isFolder", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}boolean from attribute {}isFolder...\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}isFolder of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          freeDtoDtoFolderType(_dtoFolder);
          free(_dtoFolder);
          return NULL;
        }
        _dtoFolder->folder = *((int*)_child_accessor);
        freeXsBooleanType((int*) _child_accessor);
        free(_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "url", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}url...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}url of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoFolderType(_dtoFolder);
          free(_dtoFolder);
          return NULL;
        }
        _dtoFolder->rootUrl = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "name", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}name...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoFolderType(_dtoFolder);
          free(_dtoFolder);
          return NULL;
        }
        _dtoFolder->name = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoFolderType(_dtoFolder);
      free(_dtoFolder);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoFolderType(_dtoFolder);
        free(_dtoFolder);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "file", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}file of type {http://api.grisu.arcs.org.au/dto}dtoFile.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoFileType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}file of type {http://api.grisu.arcs.org.au/dto}dtoFile.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoFolderType(_dtoFolder);
          free(_dtoFolder);
          return NULL;
        }

        _dtoFolder->childrenFiles = realloc(_dtoFolder->childrenFiles, (_dtoFolder->_sizeof_childrenFiles + 1) * sizeof(struct Grisu_dto_dtoFile));
        memcpy(&(_dtoFolder->childrenFiles[_dtoFolder->_sizeof_childrenFiles++]), _child_accessor, sizeof(struct Grisu_dto_dtoFile));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "folder", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}folder of type {http://api.grisu.arcs.org.au/dto}dtoFolder.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoFolderType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}folder of type {http://api.grisu.arcs.org.au/dto}dtoFolder.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoFolderType(_dtoFolder);
          free(_dtoFolder);
          return NULL;
        }

        _dtoFolder->childrenFolders = realloc(_dtoFolder->childrenFolders, (_dtoFolder->_sizeof_childrenFolders + 1) * sizeof(struct Grisu_dto_dtoFolder));
        memcpy(&(_dtoFolder->childrenFolders[_dtoFolder->_sizeof_childrenFolders++]), _child_accessor, sizeof(struct Grisu_dto_dtoFolder));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoFolder.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoFolder. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoFolder;
}

/**
 * Writes a DtoFolder to XML.
 *
 * @param writer The XML writer.
 * @param _dtoFolder The DtoFolder to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoFolderType(xmlTextWriterPtr writer, struct Grisu_dto_dtoFolder *_dtoFolder) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (1) { //always write the primitive attribute
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "isFolder", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}isFolder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}isFolder...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_dtoFolder->folder));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}isFolder. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}isFolder. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoFolder->rootUrl != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "url", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}url. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}url...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoFolder->rootUrl));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}url. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}url. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoFolder->name != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "name", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}name...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoFolder->name));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}name. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}name. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _dtoFolder->_sizeof_childrenFiles; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "file", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}file. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoFile for element {}file...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoFileType(writer, &(_dtoFolder->childrenFiles[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoFile for element {}file. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}file. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _dtoFolder->_sizeof_childrenFolders; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "folder", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}folder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoFolder for element {}folder...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoFolderType(writer, &(_dtoFolder->childrenFolders[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoFolder for element {}folder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}folder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoFolder.
 *
 * @param _dtoFolder The DtoFolder to free.
 */
static void freeDtoDtoFolderType(struct Grisu_dto_dtoFolder *_dtoFolder) {
  int i;
  if (_dtoFolder->rootUrl != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor rootUrl of type Grisu_dto_dtoFolder...\n");
#endif
    freeXsStringType(_dtoFolder->rootUrl);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor rootUrl of type Grisu_dto_dtoFolder...\n");
#endif
    free(_dtoFolder->rootUrl);
  }
  if (_dtoFolder->name != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor name of type Grisu_dto_dtoFolder...\n");
#endif
    freeXsStringType(_dtoFolder->name);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor name of type Grisu_dto_dtoFolder...\n");
#endif
    free(_dtoFolder->name);
  }
  if (_dtoFolder->childrenFiles != NULL) {
    for (i = 0; i < _dtoFolder->_sizeof_childrenFiles; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor childrenFiles[%i] of type Grisu_dto_dtoFolder...\n", i);
#endif
      freeDtoDtoFileType(&(_dtoFolder->childrenFiles[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor childrenFiles of type Grisu_dto_dtoFolder...\n");
#endif
    free(_dtoFolder->childrenFiles);
  }
  if (_dtoFolder->childrenFolders != NULL) {
    for (i = 0; i < _dtoFolder->_sizeof_childrenFolders; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor childrenFolders[%i] of type Grisu_dto_dtoFolder...\n", i);
#endif
      freeDtoDtoFolderType(&(_dtoFolder->childrenFolders[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor childrenFolders of type Grisu_dto_dtoFolder...\n");
#endif
    free(_dtoFolder->childrenFolders);
  }
}
#endif /* DEF_Grisu_dto_dtoFolder_M */
#ifndef DEF_Grisu_dto_dtoGridResource_M
#define DEF_Grisu_dto_dtoGridResource_M

/**
 * Reads a DtoGridResource element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}gridresource", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoGridResource, or NULL in case of error.
 */
struct Grisu_dto_dtoGridResource *xml_read_Grisu_dto_dtoGridResource(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoGridresourceElement(reader);
}

/**
 * Writes a DtoGridResource to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresource".
 *
 * @param writer The XML writer.
 * @param _dtoGridResource The DtoGridResource to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoGridResource(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResource *_dtoGridResource) {
  return xmlTextWriterWriteDtoGridresourceElementNS(writer, _dtoGridResource, 1);
}

/**
 * Frees a DtoGridResource.
 *
 * @param _dtoGridResource The DtoGridResource to free.
 */
void free_Grisu_dto_dtoGridResource(struct Grisu_dto_dtoGridResource *_dtoGridResource) {
  freeDtoDtoGridResourceType(_dtoGridResource);
  free(_dtoGridResource);
}

/**
 * Reads a DtoGridResource element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}gridresource", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoGridResource, or NULL in case of error.
 */
struct Grisu_dto_dtoGridResource *xmlTextReaderReadDtoGridresourceElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoGridResource *_dtoGridResource = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "gridresource", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}gridresource.\n");
#endif
    _dtoGridResource = xmlTextReaderReadDtoDtoGridResourceType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoGridResource == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}gridresource failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}gridresource failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoGridResource;
}

/**
 * Writes a DtoGridResource to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresource".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoGridResource The DtoGridResource to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoGridresourceElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResource *_dtoGridResource) {
  return xmlTextWriterWriteDtoGridresourceElementNS(writer, _dtoGridResource, 0);
}

/**
 * Writes a DtoGridResource to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresource".
 *
 * @param writer The XML writer.
 * @param _dtoGridResource The DtoGridResource to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoGridresourceElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResource *_dtoGridResource, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "gridresource", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}gridresource. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}gridresource...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoGridResource for root element {http://api.grisu.arcs.org.au/dto}gridresource...\n");
#endif
  status = xmlTextWriterWriteDtoDtoGridResourceType(writer, _dtoGridResource);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}gridresource. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}gridresource. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoGridResource.
 *
 * @param _dtoGridResource The DtoGridResource whose children are to be free.
 */
static void freeDtoGridresourceElement(struct Grisu_dto_dtoGridResource *_dtoGridResource) {
  freeDtoDtoGridResourceType(_dtoGridResource);
}

/**
 * Reads a DtoGridResource from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoGridResource, or NULL in case of error.
 */
static struct Grisu_dto_dtoGridResource *xmlTextReaderReadDtoDtoGridResourceType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoGridResource *_dtoGridResource = calloc(1, sizeof(struct Grisu_dto_dtoGridResource));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "applicationName", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}applicationName...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}applicationName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }
        _dtoGridResource->applicationName = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "latitude", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}double from attribute {}latitude...\n");
#endif
        _child_accessor = xmlTextReaderReadXsDoubleType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}latitude of type {http://www.w3.org/2001/XMLSchema}double.\n");
#endif
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }
        _dtoGridResource->siteLatitude = *((double*)_child_accessor);
        freeXsDoubleType((double*) _child_accessor);
        free(_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "isdesiredversioninstalled", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}boolean from attribute {}isdesiredversioninstalled...\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}isdesiredversioninstalled of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }
        _dtoGridResource->desiredSoftwareVersionInstalled = *((int*)_child_accessor);
        freeXsBooleanType((int*) _child_accessor);
        free(_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "longitude", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}double from attribute {}longitude...\n");
#endif
        _child_accessor = xmlTextReaderReadXsDoubleType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}longitude of type {http://www.w3.org/2001/XMLSchema}double.\n");
#endif
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }
        _dtoGridResource->siteLongitude = *((double*)_child_accessor);
        freeXsDoubleType((double*) _child_accessor);
        free(_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "queuename", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}queuename...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}queuename of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }
        _dtoGridResource->queueName = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "sitename", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}sitename...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}sitename of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }
        _dtoGridResource->siteName = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoGridResourceType(_dtoGridResource);
      free(_dtoGridResource);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoGridResourceType(_dtoGridResource);
        free(_dtoGridResource);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "executable", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}executable of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}executable of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->allExecutables = realloc(_dtoGridResource->allExecutables, (_dtoGridResource->_sizeof_allExecutables + 1) * sizeof(xmlChar));
        memcpy(&(_dtoGridResource->allExecutables[_dtoGridResource->_sizeof_allExecutables++]), _child_accessor, sizeof(xmlChar));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "version", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}version of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}version of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->availableApplicationVersion = realloc(_dtoGridResource->availableApplicationVersion, (_dtoGridResource->_sizeof_availableApplicationVersion + 1) * sizeof(xmlChar));
        memcpy(&(_dtoGridResource->availableApplicationVersion[_dtoGridResource->_sizeof_availableApplicationVersion++]), _child_accessor, sizeof(xmlChar));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "contactstring", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}contactstring of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}contactstring of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->contactString = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "freejobslots", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}freejobslots of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}freejobslots of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->freeJobSlots = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "jobmanager", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}jobmanager of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}jobmanager of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->jobManager = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "mainmemoryramsize", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}mainmemoryramsize of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}mainmemoryramsize of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->mainMemoryRAMSize = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "mainmemoryvirtualsize", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}mainmemoryvirtualsize of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}mainmemoryvirtualsize of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->mainMemoryVirtualSize = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "rank", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}rank of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}rank of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->rank = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "runningjobs", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}runningjobs of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}runningjobs of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->runningJobs = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "smpsize", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}smpsize of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}smpsize of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->smpSize = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "totaljobs", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}totaljobs of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}totaljobs of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->totalJobs = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "waitingjobs", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}waitingjobs of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}waitingjobs of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourceType(_dtoGridResource);
          free(_dtoGridResource);
          return NULL;
        }

        _dtoGridResource->waitingJobs = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoGridResource.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoGridResource. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoGridResource;
}

/**
 * Writes a DtoGridResource to XML.
 *
 * @param writer The XML writer.
 * @param _dtoGridResource The DtoGridResource to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoGridResourceType(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResource *_dtoGridResource) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoGridResource->applicationName != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "applicationName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}applicationName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}applicationName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoGridResource->applicationName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}applicationName. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}applicationName. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (1) { //always write the primitive attribute
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "latitude", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}latitude. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}double for attribute {}latitude...\n");
#endif
    status = xmlTextWriterWriteXsDoubleType(writer, &(_dtoGridResource->siteLatitude));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}double for attribute {}latitude. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}latitude. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (1) { //always write the primitive attribute
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "isdesiredversioninstalled", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}isdesiredversioninstalled. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}isdesiredversioninstalled...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_dtoGridResource->desiredSoftwareVersionInstalled));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for attribute {}isdesiredversioninstalled. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}isdesiredversioninstalled. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (1) { //always write the primitive attribute
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "longitude", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}longitude. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}double for attribute {}longitude...\n");
#endif
    status = xmlTextWriterWriteXsDoubleType(writer, &(_dtoGridResource->siteLongitude));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}double for attribute {}longitude. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}longitude. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoGridResource->queueName != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "queuename", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}queuename. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}queuename...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoGridResource->queueName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}queuename. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}queuename. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoGridResource->siteName != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "sitename", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}sitename. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}sitename...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoGridResource->siteName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}sitename. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}sitename. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _dtoGridResource->_sizeof_allExecutables; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "executable", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}executable. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}executable...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, &(_dtoGridResource->allExecutables[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}executable. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}executable. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _dtoGridResource->_sizeof_availableApplicationVersion; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "version", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}version. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}version...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, &(_dtoGridResource->availableApplicationVersion[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}version. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}version. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_dtoGridResource->contactString != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "contactstring", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}contactstring. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}contactstring...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoGridResource->contactString));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}contactstring. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}contactstring. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "freejobslots", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}freejobslots. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}freejobslots...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoGridResource->freeJobSlots));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}freejobslots. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}freejobslots. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_dtoGridResource->jobManager != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "jobmanager", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}jobmanager. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}jobmanager...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoGridResource->jobManager));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}jobmanager. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}jobmanager. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "mainmemoryramsize", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}mainmemoryramsize. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}mainmemoryramsize...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoGridResource->mainMemoryRAMSize));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}mainmemoryramsize. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}mainmemoryramsize. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "mainmemoryvirtualsize", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}mainmemoryvirtualsize. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}mainmemoryvirtualsize...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoGridResource->mainMemoryVirtualSize));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}mainmemoryvirtualsize. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}mainmemoryvirtualsize. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "rank", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}rank. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}rank...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoGridResource->rank));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}rank. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}rank. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "runningjobs", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}runningjobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}runningjobs...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoGridResource->runningJobs));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}runningjobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}runningjobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "smpsize", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}smpsize. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}smpsize...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoGridResource->smpSize));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}smpsize. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}smpsize. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "totaljobs", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}totaljobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}totaljobs...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoGridResource->totalJobs));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}totaljobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}totaljobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "waitingjobs", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}waitingjobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}waitingjobs...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoGridResource->waitingJobs));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}waitingjobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}waitingjobs. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoGridResource.
 *
 * @param _dtoGridResource The DtoGridResource to free.
 */
static void freeDtoDtoGridResourceType(struct Grisu_dto_dtoGridResource *_dtoGridResource) {
  int i;
  if (_dtoGridResource->applicationName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor applicationName of type Grisu_dto_dtoGridResource...\n");
#endif
    freeXsStringType(_dtoGridResource->applicationName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor applicationName of type Grisu_dto_dtoGridResource...\n");
#endif
    free(_dtoGridResource->applicationName);
  }
  if (_dtoGridResource->queueName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor queueName of type Grisu_dto_dtoGridResource...\n");
#endif
    freeXsStringType(_dtoGridResource->queueName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor queueName of type Grisu_dto_dtoGridResource...\n");
#endif
    free(_dtoGridResource->queueName);
  }
  if (_dtoGridResource->siteName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor siteName of type Grisu_dto_dtoGridResource...\n");
#endif
    freeXsStringType(_dtoGridResource->siteName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor siteName of type Grisu_dto_dtoGridResource...\n");
#endif
    free(_dtoGridResource->siteName);
  }
  if (_dtoGridResource->allExecutables != NULL) {
    for (i = 0; i < _dtoGridResource->_sizeof_allExecutables; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor allExecutables[%i] of type Grisu_dto_dtoGridResource...\n", i);
#endif
      freeXsStringType(&(_dtoGridResource->allExecutables[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor allExecutables of type Grisu_dto_dtoGridResource...\n");
#endif
    free(_dtoGridResource->allExecutables);
  }
  if (_dtoGridResource->availableApplicationVersion != NULL) {
    for (i = 0; i < _dtoGridResource->_sizeof_availableApplicationVersion; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor availableApplicationVersion[%i] of type Grisu_dto_dtoGridResource...\n", i);
#endif
      freeXsStringType(&(_dtoGridResource->availableApplicationVersion[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor availableApplicationVersion of type Grisu_dto_dtoGridResource...\n");
#endif
    free(_dtoGridResource->availableApplicationVersion);
  }
  if (_dtoGridResource->contactString != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor contactString of type Grisu_dto_dtoGridResource...\n");
#endif
    freeXsStringType(_dtoGridResource->contactString);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor contactString of type Grisu_dto_dtoGridResource...\n");
#endif
    free(_dtoGridResource->contactString);
  }
  if (_dtoGridResource->jobManager != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor jobManager of type Grisu_dto_dtoGridResource...\n");
#endif
    freeXsStringType(_dtoGridResource->jobManager);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor jobManager of type Grisu_dto_dtoGridResource...\n");
#endif
    free(_dtoGridResource->jobManager);
  }
}
#endif /* DEF_Grisu_dto_dtoGridResource_M */
#ifndef DEF_Grisu_dto_dtoGridResources_M
#define DEF_Grisu_dto_dtoGridResources_M

/**
 * Reads a DtoGridResources element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}gridresources", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoGridResources, or NULL in case of error.
 */
struct Grisu_dto_dtoGridResources *xml_read_Grisu_dto_dtoGridResources(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoGridresourcesElement(reader);
}

/**
 * Writes a DtoGridResources to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresources".
 *
 * @param writer The XML writer.
 * @param _dtoGridResources The DtoGridResources to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoGridResources(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResources *_dtoGridResources) {
  return xmlTextWriterWriteDtoGridresourcesElementNS(writer, _dtoGridResources, 1);
}

/**
 * Frees a DtoGridResources.
 *
 * @param _dtoGridResources The DtoGridResources to free.
 */
void free_Grisu_dto_dtoGridResources(struct Grisu_dto_dtoGridResources *_dtoGridResources) {
  freeDtoDtoGridResourcesType(_dtoGridResources);
  free(_dtoGridResources);
}

/**
 * Reads a DtoGridResources element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}gridresources", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoGridResources, or NULL in case of error.
 */
struct Grisu_dto_dtoGridResources *xmlTextReaderReadDtoGridresourcesElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoGridResources *_dtoGridResources = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "gridresources", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}gridresources.\n");
#endif
    _dtoGridResources = xmlTextReaderReadDtoDtoGridResourcesType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoGridResources == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}gridresources failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}gridresources failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoGridResources;
}

/**
 * Writes a DtoGridResources to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresources".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoGridResources The DtoGridResources to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoGridresourcesElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResources *_dtoGridResources) {
  return xmlTextWriterWriteDtoGridresourcesElementNS(writer, _dtoGridResources, 0);
}

/**
 * Writes a DtoGridResources to XML under element name "{http://api.grisu.arcs.org.au/dto}gridresources".
 *
 * @param writer The XML writer.
 * @param _dtoGridResources The DtoGridResources to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoGridresourcesElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResources *_dtoGridResources, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "gridresources", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}gridresources. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}gridresources...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoGridResources for root element {http://api.grisu.arcs.org.au/dto}gridresources...\n");
#endif
  status = xmlTextWriterWriteDtoDtoGridResourcesType(writer, _dtoGridResources);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}gridresources. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}gridresources. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoGridResources.
 *
 * @param _dtoGridResources The DtoGridResources whose children are to be free.
 */
static void freeDtoGridresourcesElement(struct Grisu_dto_dtoGridResources *_dtoGridResources) {
  freeDtoDtoGridResourcesType(_dtoGridResources);
}

/**
 * Reads a DtoGridResources from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoGridResources, or NULL in case of error.
 */
static struct Grisu_dto_dtoGridResources *xmlTextReaderReadDtoDtoGridResourcesType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoGridResources *_dtoGridResources = calloc(1, sizeof(struct Grisu_dto_dtoGridResources));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoGridResourcesType(_dtoGridResources);
        free(_dtoGridResources);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "gridresource", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}gridresource of type {http://api.grisu.arcs.org.au/dto}dtoGridResource.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoGridResourceType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}gridresource of type {http://api.grisu.arcs.org.au/dto}dtoGridResource.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoGridResourcesType(_dtoGridResources);
          free(_dtoGridResources);
          return NULL;
        }

        _dtoGridResources->gridResources = realloc(_dtoGridResources->gridResources, (_dtoGridResources->_sizeof_gridResources + 1) * sizeof(struct Grisu_dto_dtoGridResource));
        memcpy(&(_dtoGridResources->gridResources[_dtoGridResources->_sizeof_gridResources++]), _child_accessor, sizeof(struct Grisu_dto_dtoGridResource));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoGridResources.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoGridResources. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoGridResources;
}

/**
 * Writes a DtoGridResources to XML.
 *
 * @param writer The XML writer.
 * @param _dtoGridResources The DtoGridResources to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoGridResourcesType(xmlTextWriterPtr writer, struct Grisu_dto_dtoGridResources *_dtoGridResources) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _dtoGridResources->_sizeof_gridResources; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "gridresource", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}gridresource. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoGridResource for element {}gridresource...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoGridResourceType(writer, &(_dtoGridResources->gridResources[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoGridResource for element {}gridresource. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}gridresource. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoGridResources.
 *
 * @param _dtoGridResources The DtoGridResources to free.
 */
static void freeDtoDtoGridResourcesType(struct Grisu_dto_dtoGridResources *_dtoGridResources) {
  int i;
  if (_dtoGridResources->gridResources != NULL) {
    for (i = 0; i < _dtoGridResources->_sizeof_gridResources; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor gridResources[%i] of type Grisu_dto_dtoGridResources...\n", i);
#endif
      freeDtoDtoGridResourceType(&(_dtoGridResources->gridResources[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor gridResources of type Grisu_dto_dtoGridResources...\n");
#endif
    free(_dtoGridResources->gridResources);
  }
}
#endif /* DEF_Grisu_dto_dtoGridResources_M */
#ifndef DEF_Grisu_dto_dtoHost_M
#define DEF_Grisu_dto_dtoHost_M

/**
 * Reads a DtoHost element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}host", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoHost, or NULL in case of error.
 */
struct Grisu_dto_dtoHost *xml_read_Grisu_dto_dtoHost(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoHostElement(reader);
}

/**
 * Writes a DtoHost to XML under element name "{http://api.grisu.arcs.org.au/dto}host".
 *
 * @param writer The XML writer.
 * @param _dtoHost The DtoHost to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoHost(xmlTextWriterPtr writer, struct Grisu_dto_dtoHost *_dtoHost) {
  return xmlTextWriterWriteDtoHostElementNS(writer, _dtoHost, 1);
}

/**
 * Frees a DtoHost.
 *
 * @param _dtoHost The DtoHost to free.
 */
void free_Grisu_dto_dtoHost(struct Grisu_dto_dtoHost *_dtoHost) {
  freeDtoDtoHostType(_dtoHost);
  free(_dtoHost);
}

/**
 * Reads a DtoHost element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}host", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoHost, or NULL in case of error.
 */
struct Grisu_dto_dtoHost *xmlTextReaderReadDtoHostElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoHost *_dtoHost = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "host", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}host.\n");
#endif
    _dtoHost = xmlTextReaderReadDtoDtoHostType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoHost == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}host failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}host failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoHost;
}

/**
 * Writes a DtoHost to XML under element name "{http://api.grisu.arcs.org.au/dto}host".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoHost The DtoHost to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoHostElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoHost *_dtoHost) {
  return xmlTextWriterWriteDtoHostElementNS(writer, _dtoHost, 0);
}

/**
 * Writes a DtoHost to XML under element name "{http://api.grisu.arcs.org.au/dto}host".
 *
 * @param writer The XML writer.
 * @param _dtoHost The DtoHost to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoHostElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoHost *_dtoHost, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "host", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}host. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}host...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoHost for root element {http://api.grisu.arcs.org.au/dto}host...\n");
#endif
  status = xmlTextWriterWriteDtoDtoHostType(writer, _dtoHost);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}host. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}host. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoHost.
 *
 * @param _dtoHost The DtoHost whose children are to be free.
 */
static void freeDtoHostElement(struct Grisu_dto_dtoHost *_dtoHost) {
  freeDtoDtoHostType(_dtoHost);
}

/**
 * Reads a DtoHost from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoHost, or NULL in case of error.
 */
static struct Grisu_dto_dtoHost *xmlTextReaderReadDtoDtoHostType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoHost *_dtoHost = calloc(1, sizeof(struct Grisu_dto_dtoHost));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoHostType(_dtoHost);
        free(_dtoHost);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "hostname", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}hostname of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}hostname of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoHostType(_dtoHost);
          free(_dtoHost);
          return NULL;
        }

        _dtoHost->hostNameString = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "sitename", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}sitename of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}sitename of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoHostType(_dtoHost);
          free(_dtoHost);
          return NULL;
        }

        _dtoHost->siteNameString = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoHost.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoHost. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoHost;
}

/**
 * Writes a DtoHost to XML.
 *
 * @param writer The XML writer.
 * @param _dtoHost The DtoHost to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoHostType(xmlTextWriterPtr writer, struct Grisu_dto_dtoHost *_dtoHost) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_dtoHost->hostNameString != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "hostname", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}hostname. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}hostname...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoHost->hostNameString));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}hostname. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}hostname. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_dtoHost->siteNameString != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "sitename", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}sitename. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}sitename...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoHost->siteNameString));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}sitename. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}sitename. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoHost.
 *
 * @param _dtoHost The DtoHost to free.
 */
static void freeDtoDtoHostType(struct Grisu_dto_dtoHost *_dtoHost) {
  int i;
  if (_dtoHost->hostNameString != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor hostNameString of type Grisu_dto_dtoHost...\n");
#endif
    freeXsStringType(_dtoHost->hostNameString);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor hostNameString of type Grisu_dto_dtoHost...\n");
#endif
    free(_dtoHost->hostNameString);
  }
  if (_dtoHost->siteNameString != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor siteNameString of type Grisu_dto_dtoHost...\n");
#endif
    freeXsStringType(_dtoHost->siteNameString);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor siteNameString of type Grisu_dto_dtoHost...\n");
#endif
    free(_dtoHost->siteNameString);
  }
}
#endif /* DEF_Grisu_dto_dtoHost_M */
#ifndef DEF_Grisu_dto_dtoHostsInfo_M
#define DEF_Grisu_dto_dtoHostsInfo_M

/**
 * Reads a DtoHostsInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}hostsinfo", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoHostsInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoHostsInfo *xml_read_Grisu_dto_dtoHostsInfo(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoHostsinfoElement(reader);
}

/**
 * Writes a DtoHostsInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}hostsinfo".
 *
 * @param writer The XML writer.
 * @param _dtoHostsInfo The DtoHostsInfo to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoHostsInfo(xmlTextWriterPtr writer, struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo) {
  return xmlTextWriterWriteDtoHostsinfoElementNS(writer, _dtoHostsInfo, 1);
}

/**
 * Frees a DtoHostsInfo.
 *
 * @param _dtoHostsInfo The DtoHostsInfo to free.
 */
void free_Grisu_dto_dtoHostsInfo(struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo) {
  freeDtoDtoHostsInfoType(_dtoHostsInfo);
  free(_dtoHostsInfo);
}

/**
 * Reads a DtoHostsInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}hostsinfo", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoHostsInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoHostsInfo *xmlTextReaderReadDtoHostsinfoElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "hostsinfo", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}hostsinfo.\n");
#endif
    _dtoHostsInfo = xmlTextReaderReadDtoDtoHostsInfoType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoHostsInfo == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}hostsinfo failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}hostsinfo failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoHostsInfo;
}

/**
 * Writes a DtoHostsInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}hostsinfo".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoHostsInfo The DtoHostsInfo to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoHostsinfoElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo) {
  return xmlTextWriterWriteDtoHostsinfoElementNS(writer, _dtoHostsInfo, 0);
}

/**
 * Writes a DtoHostsInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}hostsinfo".
 *
 * @param writer The XML writer.
 * @param _dtoHostsInfo The DtoHostsInfo to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoHostsinfoElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "hostsinfo", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}hostsinfo. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}hostsinfo...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoHostsInfo for root element {http://api.grisu.arcs.org.au/dto}hostsinfo...\n");
#endif
  status = xmlTextWriterWriteDtoDtoHostsInfoType(writer, _dtoHostsInfo);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}hostsinfo. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}hostsinfo. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoHostsInfo.
 *
 * @param _dtoHostsInfo The DtoHostsInfo whose children are to be free.
 */
static void freeDtoHostsinfoElement(struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo) {
  freeDtoDtoHostsInfoType(_dtoHostsInfo);
}

/**
 * Reads a DtoHostsInfo from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoHostsInfo, or NULL in case of error.
 */
static struct Grisu_dto_dtoHostsInfo *xmlTextReaderReadDtoDtoHostsInfoType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo = calloc(1, sizeof(struct Grisu_dto_dtoHostsInfo));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoHostsInfoType(_dtoHostsInfo);
        free(_dtoHostsInfo);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "host", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}host of type {http://api.grisu.arcs.org.au/dto}dtoHost.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoHostType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}host of type {http://api.grisu.arcs.org.au/dto}dtoHost.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoHostsInfoType(_dtoHostsInfo);
          free(_dtoHostsInfo);
          return NULL;
        }

        _dtoHostsInfo->allHosts = realloc(_dtoHostsInfo->allHosts, (_dtoHostsInfo->_sizeof_allHosts + 1) * sizeof(struct Grisu_dto_dtoHost));
        memcpy(&(_dtoHostsInfo->allHosts[_dtoHostsInfo->_sizeof_allHosts++]), _child_accessor, sizeof(struct Grisu_dto_dtoHost));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoHostsInfo.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoHostsInfo. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoHostsInfo;
}

/**
 * Writes a DtoHostsInfo to XML.
 *
 * @param writer The XML writer.
 * @param _dtoHostsInfo The DtoHostsInfo to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoHostsInfoType(xmlTextWriterPtr writer, struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _dtoHostsInfo->_sizeof_allHosts; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "host", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}host. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoHost for element {}host...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoHostType(writer, &(_dtoHostsInfo->allHosts[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoHost for element {}host. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}host. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoHostsInfo.
 *
 * @param _dtoHostsInfo The DtoHostsInfo to free.
 */
static void freeDtoDtoHostsInfoType(struct Grisu_dto_dtoHostsInfo *_dtoHostsInfo) {
  int i;
  if (_dtoHostsInfo->allHosts != NULL) {
    for (i = 0; i < _dtoHostsInfo->_sizeof_allHosts; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor allHosts[%i] of type Grisu_dto_dtoHostsInfo...\n", i);
#endif
      freeDtoDtoHostType(&(_dtoHostsInfo->allHosts[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor allHosts of type Grisu_dto_dtoHostsInfo...\n");
#endif
    free(_dtoHostsInfo->allHosts);
  }
}
#endif /* DEF_Grisu_dto_dtoHostsInfo_M */
#ifndef DEF_Grisu_dto_dtoJob_M
#define DEF_Grisu_dto_dtoJob_M

/**
 * Reads a DtoJob element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}job", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoJob, or NULL in case of error.
 */
struct Grisu_dto_dtoJob *xml_read_Grisu_dto_dtoJob(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoJobElement(reader);
}

/**
 * Writes a DtoJob to XML under element name "{http://api.grisu.arcs.org.au/dto}job".
 *
 * @param writer The XML writer.
 * @param _dtoJob The DtoJob to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoJob(xmlTextWriterPtr writer, struct Grisu_dto_dtoJob *_dtoJob) {
  return xmlTextWriterWriteDtoJobElementNS(writer, _dtoJob, 1);
}

/**
 * Frees a DtoJob.
 *
 * @param _dtoJob The DtoJob to free.
 */
void free_Grisu_dto_dtoJob(struct Grisu_dto_dtoJob *_dtoJob) {
  freeDtoDtoJobType(_dtoJob);
  free(_dtoJob);
}

/**
 * Reads a DtoJob element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}job", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoJob, or NULL in case of error.
 */
struct Grisu_dto_dtoJob *xmlTextReaderReadDtoJobElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoJob *_dtoJob = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "job", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}job.\n");
#endif
    _dtoJob = xmlTextReaderReadDtoDtoJobType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoJob == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}job failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}job failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoJob;
}

/**
 * Writes a DtoJob to XML under element name "{http://api.grisu.arcs.org.au/dto}job".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoJob The DtoJob to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoJobElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoJob *_dtoJob) {
  return xmlTextWriterWriteDtoJobElementNS(writer, _dtoJob, 0);
}

/**
 * Writes a DtoJob to XML under element name "{http://api.grisu.arcs.org.au/dto}job".
 *
 * @param writer The XML writer.
 * @param _dtoJob The DtoJob to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoJobElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoJob *_dtoJob, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "job", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}job. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}job...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoJob for root element {http://api.grisu.arcs.org.au/dto}job...\n");
#endif
  status = xmlTextWriterWriteDtoDtoJobType(writer, _dtoJob);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}job. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}job. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoJob.
 *
 * @param _dtoJob The DtoJob whose children are to be free.
 */
static void freeDtoJobElement(struct Grisu_dto_dtoJob *_dtoJob) {
  freeDtoDtoJobType(_dtoJob);
}

/**
 * Reads a DtoJob from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoJob, or NULL in case of error.
 */
static struct Grisu_dto_dtoJob *xmlTextReaderReadDtoDtoJobType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoJob *_dtoJob = calloc(1, sizeof(struct Grisu_dto_dtoJob));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoJobType(_dtoJob);
        free(_dtoJob);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "logmessages", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}logmessages of type {http://api.grisu.arcs.org.au/dto}dtoLogMessages.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoLogMessagesType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}logmessages of type {http://api.grisu.arcs.org.au/dto}dtoLogMessages.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoJobType(_dtoJob);
          free(_dtoJob);
          return NULL;
        }

        _dtoJob->logMessages = ((struct Grisu_dto_dtoLogMessages*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "jobproperty", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}jobproperty of type {http://api.grisu.arcs.org.au/dto}dtoJobProperty.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoJobPropertyType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}jobproperty of type {http://api.grisu.arcs.org.au/dto}dtoJobProperty.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoJobType(_dtoJob);
          free(_dtoJob);
          return NULL;
        }

        _dtoJob->properties = realloc(_dtoJob->properties, (_dtoJob->_sizeof_properties + 1) * sizeof(struct Grisu_dto_dtoJobProperty));
        memcpy(&(_dtoJob->properties[_dtoJob->_sizeof_properties++]), _child_accessor, sizeof(struct Grisu_dto_dtoJobProperty));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "status", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}status of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}status of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoJobType(_dtoJob);
          free(_dtoJob);
          return NULL;
        }

        _dtoJob->status = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoJob.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoJob. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoJob;
}

/**
 * Writes a DtoJob to XML.
 *
 * @param writer The XML writer.
 * @param _dtoJob The DtoJob to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoJobType(xmlTextWriterPtr writer, struct Grisu_dto_dtoJob *_dtoJob) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_dtoJob->logMessages != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "logmessages", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}logmessages. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoLogMessages for element {}logmessages...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoLogMessagesType(writer, (_dtoJob->logMessages));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoLogMessages for element {}logmessages. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}logmessages. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _dtoJob->_sizeof_properties; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "jobproperty", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}jobproperty. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoJobProperty for element {}jobproperty...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoJobPropertyType(writer, &(_dtoJob->properties[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoJobProperty for element {}jobproperty. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}jobproperty. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "status", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}status. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}status...\n", status);
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_dtoJob->status));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}status. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}status. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoJob.
 *
 * @param _dtoJob The DtoJob to free.
 */
static void freeDtoDtoJobType(struct Grisu_dto_dtoJob *_dtoJob) {
  int i;
  if (_dtoJob->logMessages != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor logMessages of type Grisu_dto_dtoJob...\n");
#endif
    freeDtoDtoLogMessagesType(_dtoJob->logMessages);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor logMessages of type Grisu_dto_dtoJob...\n");
#endif
    free(_dtoJob->logMessages);
  }
  if (_dtoJob->properties != NULL) {
    for (i = 0; i < _dtoJob->_sizeof_properties; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor properties[%i] of type Grisu_dto_dtoJob...\n", i);
#endif
      freeDtoDtoJobPropertyType(&(_dtoJob->properties[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor properties of type Grisu_dto_dtoJob...\n");
#endif
    free(_dtoJob->properties);
  }
}
#endif /* DEF_Grisu_dto_dtoJob_M */
#ifndef DEF_Grisu_dto_dtoJobProperty_M
#define DEF_Grisu_dto_dtoJobProperty_M

/**
 * Reads a DtoJobProperty element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}jobproperty", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoJobProperty, or NULL in case of error.
 */
struct Grisu_dto_dtoJobProperty *xml_read_Grisu_dto_dtoJobProperty(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoJobpropertyElement(reader);
}

/**
 * Writes a DtoJobProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}jobproperty".
 *
 * @param writer The XML writer.
 * @param _dtoJobProperty The DtoJobProperty to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoJobProperty(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobProperty *_dtoJobProperty) {
  return xmlTextWriterWriteDtoJobpropertyElementNS(writer, _dtoJobProperty, 1);
}

/**
 * Frees a DtoJobProperty.
 *
 * @param _dtoJobProperty The DtoJobProperty to free.
 */
void free_Grisu_dto_dtoJobProperty(struct Grisu_dto_dtoJobProperty *_dtoJobProperty) {
  freeDtoDtoJobPropertyType(_dtoJobProperty);
  free(_dtoJobProperty);
}

/**
 * Reads a DtoJobProperty element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}jobproperty", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoJobProperty, or NULL in case of error.
 */
struct Grisu_dto_dtoJobProperty *xmlTextReaderReadDtoJobpropertyElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoJobProperty *_dtoJobProperty = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "jobproperty", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}jobproperty.\n");
#endif
    _dtoJobProperty = xmlTextReaderReadDtoDtoJobPropertyType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoJobProperty == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}jobproperty failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}jobproperty failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoJobProperty;
}

/**
 * Writes a DtoJobProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}jobproperty".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoJobProperty The DtoJobProperty to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoJobpropertyElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobProperty *_dtoJobProperty) {
  return xmlTextWriterWriteDtoJobpropertyElementNS(writer, _dtoJobProperty, 0);
}

/**
 * Writes a DtoJobProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}jobproperty".
 *
 * @param writer The XML writer.
 * @param _dtoJobProperty The DtoJobProperty to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoJobpropertyElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobProperty *_dtoJobProperty, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "jobproperty", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}jobproperty. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}jobproperty...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoJobProperty for root element {http://api.grisu.arcs.org.au/dto}jobproperty...\n");
#endif
  status = xmlTextWriterWriteDtoDtoJobPropertyType(writer, _dtoJobProperty);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}jobproperty. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}jobproperty. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoJobProperty.
 *
 * @param _dtoJobProperty The DtoJobProperty whose children are to be free.
 */
static void freeDtoJobpropertyElement(struct Grisu_dto_dtoJobProperty *_dtoJobProperty) {
  freeDtoDtoJobPropertyType(_dtoJobProperty);
}

/**
 * Reads a DtoJobProperty from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoJobProperty, or NULL in case of error.
 */
static struct Grisu_dto_dtoJobProperty *xmlTextReaderReadDtoDtoJobPropertyType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoJobProperty *_dtoJobProperty = calloc(1, sizeof(struct Grisu_dto_dtoJobProperty));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "key", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}key...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}key of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoJobPropertyType(_dtoJobProperty);
          free(_dtoJobProperty);
          return NULL;
        }
        _dtoJobProperty->key = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoJobPropertyType(_dtoJobProperty);
      free(_dtoJobProperty);
      return NULL;
    }
  }

  if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from element value...\n");
#endif
    _child_accessor = xmlTextReaderReadXsStringType(reader);
    if (_child_accessor == NULL) {
      //panic: unable to return the value for some reason.
#if DEBUG_ENUNCIATE
      printf("Failed to read value of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
      freeDtoDtoJobPropertyType(_dtoJobProperty);
      free(_dtoJobProperty);
      return NULL;
    }
    _dtoJobProperty->value = ((xmlChar*)_child_accessor);
  }
  else {
    _dtoJobProperty->value = BAD_CAST "";
  }


  return _dtoJobProperty;
}

/**
 * Writes a DtoJobProperty to XML.
 *
 * @param writer The XML writer.
 * @param _dtoJobProperty The DtoJobProperty to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoJobPropertyType(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobProperty *_dtoJobProperty) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoJobProperty->key != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "key", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}key. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}key...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoJobProperty->key));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}key. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}key. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoJobProperty->value != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element value...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoJobProperty->value));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element value. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoJobProperty.
 *
 * @param _dtoJobProperty The DtoJobProperty to free.
 */
static void freeDtoDtoJobPropertyType(struct Grisu_dto_dtoJobProperty *_dtoJobProperty) {
  int i;
  if (_dtoJobProperty->key != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor key of type Grisu_dto_dtoJobProperty...\n");
#endif
    freeXsStringType(_dtoJobProperty->key);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor key of type Grisu_dto_dtoJobProperty...\n");
#endif
    free(_dtoJobProperty->key);
  }
  if (_dtoJobProperty->value != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor value of type Grisu_dto_dtoJobProperty...\n");
#endif
    freeXsStringType(_dtoJobProperty->value);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor value of type Grisu_dto_dtoJobProperty...\n");
#endif
    free(_dtoJobProperty->value);
  }
}
#endif /* DEF_Grisu_dto_dtoJobProperty_M */
#ifndef DEF_Grisu_dto_dtoJobs_M
#define DEF_Grisu_dto_dtoJobs_M

/**
 * Reads a DtoJobs element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}jobs", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoJobs, or NULL in case of error.
 */
struct Grisu_dto_dtoJobs *xml_read_Grisu_dto_dtoJobs(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoJobsElement(reader);
}

/**
 * Writes a DtoJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}jobs".
 *
 * @param writer The XML writer.
 * @param _dtoJobs The DtoJobs to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoJobs(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobs *_dtoJobs) {
  return xmlTextWriterWriteDtoJobsElementNS(writer, _dtoJobs, 1);
}

/**
 * Frees a DtoJobs.
 *
 * @param _dtoJobs The DtoJobs to free.
 */
void free_Grisu_dto_dtoJobs(struct Grisu_dto_dtoJobs *_dtoJobs) {
  freeDtoDtoJobsType(_dtoJobs);
  free(_dtoJobs);
}

/**
 * Reads a DtoJobs element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}jobs", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoJobs, or NULL in case of error.
 */
struct Grisu_dto_dtoJobs *xmlTextReaderReadDtoJobsElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoJobs *_dtoJobs = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "jobs", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}jobs.\n");
#endif
    _dtoJobs = xmlTextReaderReadDtoDtoJobsType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoJobs == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}jobs failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}jobs failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoJobs;
}

/**
 * Writes a DtoJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}jobs".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoJobs The DtoJobs to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoJobsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobs *_dtoJobs) {
  return xmlTextWriterWriteDtoJobsElementNS(writer, _dtoJobs, 0);
}

/**
 * Writes a DtoJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}jobs".
 *
 * @param writer The XML writer.
 * @param _dtoJobs The DtoJobs to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoJobsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobs *_dtoJobs, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "jobs", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}jobs. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}jobs...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoJobs for root element {http://api.grisu.arcs.org.au/dto}jobs...\n");
#endif
  status = xmlTextWriterWriteDtoDtoJobsType(writer, _dtoJobs);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}jobs. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}jobs. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoJobs.
 *
 * @param _dtoJobs The DtoJobs whose children are to be free.
 */
static void freeDtoJobsElement(struct Grisu_dto_dtoJobs *_dtoJobs) {
  freeDtoDtoJobsType(_dtoJobs);
}

/**
 * Reads a DtoJobs from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoJobs, or NULL in case of error.
 */
static struct Grisu_dto_dtoJobs *xmlTextReaderReadDtoDtoJobsType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoJobs *_dtoJobs = calloc(1, sizeof(struct Grisu_dto_dtoJobs));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoJobsType(_dtoJobs);
        free(_dtoJobs);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "job", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}job of type {http://api.grisu.arcs.org.au/dto}dtoJob.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoJobType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}job of type {http://api.grisu.arcs.org.au/dto}dtoJob.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoJobsType(_dtoJobs);
          free(_dtoJobs);
          return NULL;
        }

        _dtoJobs->allJobs = realloc(_dtoJobs->allJobs, (_dtoJobs->_sizeof_allJobs + 1) * sizeof(struct Grisu_dto_dtoJob));
        memcpy(&(_dtoJobs->allJobs[_dtoJobs->_sizeof_allJobs++]), _child_accessor, sizeof(struct Grisu_dto_dtoJob));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoJobs.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoJobs. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoJobs;
}

/**
 * Writes a DtoJobs to XML.
 *
 * @param writer The XML writer.
 * @param _dtoJobs The DtoJobs to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoJobsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoJobs *_dtoJobs) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _dtoJobs->_sizeof_allJobs; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "job", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}job. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoJob for element {}job...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoJobType(writer, &(_dtoJobs->allJobs[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoJob for element {}job. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}job. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoJobs.
 *
 * @param _dtoJobs The DtoJobs to free.
 */
static void freeDtoDtoJobsType(struct Grisu_dto_dtoJobs *_dtoJobs) {
  int i;
  if (_dtoJobs->allJobs != NULL) {
    for (i = 0; i < _dtoJobs->_sizeof_allJobs; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor allJobs[%i] of type Grisu_dto_dtoJobs...\n", i);
#endif
      freeDtoDtoJobType(&(_dtoJobs->allJobs[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor allJobs of type Grisu_dto_dtoJobs...\n");
#endif
    free(_dtoJobs->allJobs);
  }
}
#endif /* DEF_Grisu_dto_dtoJobs_M */
#ifndef DEF_Grisu_dto_dtoLogItem_M
#define DEF_Grisu_dto_dtoLogItem_M

/**
 * Reads a DtoLogItem element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}dtoLogItem", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoLogItem, or NULL in case of error.
 */
struct Grisu_dto_dtoLogItem *xml_read_Grisu_dto_dtoLogItem(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoDtoLogItemElement(reader);
}

/**
 * Writes a DtoLogItem to XML under element name "{http://api.grisu.arcs.org.au/dto}dtoLogItem".
 *
 * @param writer The XML writer.
 * @param _dtoLogItem The DtoLogItem to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoLogItem(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogItem *_dtoLogItem) {
  return xmlTextWriterWriteDtoDtoLogItemElementNS(writer, _dtoLogItem, 1);
}

/**
 * Frees a DtoLogItem.
 *
 * @param _dtoLogItem The DtoLogItem to free.
 */
void free_Grisu_dto_dtoLogItem(struct Grisu_dto_dtoLogItem *_dtoLogItem) {
  freeDtoDtoLogItemType(_dtoLogItem);
  free(_dtoLogItem);
}

/**
 * Reads a DtoLogItem element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}dtoLogItem", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoLogItem, or NULL in case of error.
 */
struct Grisu_dto_dtoLogItem *xmlTextReaderReadDtoDtoLogItemElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoLogItem *_dtoLogItem = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "dtoLogItem", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}dtoLogItem.\n");
#endif
    _dtoLogItem = xmlTextReaderReadDtoDtoLogItemType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoLogItem == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}dtoLogItem failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}dtoLogItem failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoLogItem;
}

/**
 * Writes a DtoLogItem to XML under element name "{http://api.grisu.arcs.org.au/dto}dtoLogItem".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoLogItem The DtoLogItem to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoDtoLogItemElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogItem *_dtoLogItem) {
  return xmlTextWriterWriteDtoDtoLogItemElementNS(writer, _dtoLogItem, 0);
}

/**
 * Writes a DtoLogItem to XML under element name "{http://api.grisu.arcs.org.au/dto}dtoLogItem".
 *
 * @param writer The XML writer.
 * @param _dtoLogItem The DtoLogItem to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoDtoLogItemElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogItem *_dtoLogItem, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "dtoLogItem", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}dtoLogItem. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}dtoLogItem...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoLogItem for root element {http://api.grisu.arcs.org.au/dto}dtoLogItem...\n");
#endif
  status = xmlTextWriterWriteDtoDtoLogItemType(writer, _dtoLogItem);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}dtoLogItem. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}dtoLogItem. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoLogItem.
 *
 * @param _dtoLogItem The DtoLogItem whose children are to be free.
 */
static void freeDtoDtoLogItemElement(struct Grisu_dto_dtoLogItem *_dtoLogItem) {
  freeDtoDtoLogItemType(_dtoLogItem);
}

/**
 * Reads a DtoLogItem from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoLogItem, or NULL in case of error.
 */
static struct Grisu_dto_dtoLogItem *xmlTextReaderReadDtoDtoLogItemType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoLogItem *_dtoLogItem = calloc(1, sizeof(struct Grisu_dto_dtoLogItem));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "time", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}dateTime from attribute {}time...\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateTimeType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}time of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
          freeDtoDtoLogItemType(_dtoLogItem);
          free(_dtoLogItem);
          return NULL;
        }
        _dtoLogItem->time = ((struct tm*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoLogItemType(_dtoLogItem);
      free(_dtoLogItem);
      return NULL;
    }
  }

  if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from element value...\n");
#endif
    _child_accessor = xmlTextReaderReadXsStringType(reader);
    if (_child_accessor == NULL) {
      //panic: unable to return the value for some reason.
#if DEBUG_ENUNCIATE
      printf("Failed to read value of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
      freeDtoDtoLogItemType(_dtoLogItem);
      free(_dtoLogItem);
      return NULL;
    }
    _dtoLogItem->logMessage = ((xmlChar*)_child_accessor);
  }
  else {
    _dtoLogItem->logMessage = BAD_CAST "";
  }


  return _dtoLogItem;
}

/**
 * Writes a DtoLogItem to XML.
 *
 * @param writer The XML writer.
 * @param _dtoLogItem The DtoLogItem to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoLogItemType(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogItem *_dtoLogItem) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoLogItem->time != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "time", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}time. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}dateTime for attribute {}time...\n");
#endif
    status = xmlTextWriterWriteXsDateTimeType(writer, (_dtoLogItem->time));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}dateTime for attribute {}time. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}time. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoLogItem->logMessage != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element value...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoLogItem->logMessage));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element value. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoLogItem.
 *
 * @param _dtoLogItem The DtoLogItem to free.
 */
static void freeDtoDtoLogItemType(struct Grisu_dto_dtoLogItem *_dtoLogItem) {
  int i;
  if (_dtoLogItem->time != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor time of type Grisu_dto_dtoLogItem...\n");
#endif
    freeXsDateTimeType(_dtoLogItem->time);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor time of type Grisu_dto_dtoLogItem...\n");
#endif
    free(_dtoLogItem->time);
  }
  if (_dtoLogItem->logMessage != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor logMessage of type Grisu_dto_dtoLogItem...\n");
#endif
    freeXsStringType(_dtoLogItem->logMessage);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor logMessage of type Grisu_dto_dtoLogItem...\n");
#endif
    free(_dtoLogItem->logMessage);
  }
}
#endif /* DEF_Grisu_dto_dtoLogItem_M */
#ifndef DEF_Grisu_dto_dtoLogMessage_M
#define DEF_Grisu_dto_dtoLogMessage_M

/**
 * Reads a DtoLogMessage element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}logMessage", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoLogMessage, or NULL in case of error.
 */
struct Grisu_dto_dtoLogMessage *xml_read_Grisu_dto_dtoLogMessage(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoLogMessageElement(reader);
}

/**
 * Writes a DtoLogMessage to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessage".
 *
 * @param writer The XML writer.
 * @param _dtoLogMessage The DtoLogMessage to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoLogMessage(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessage *_dtoLogMessage) {
  return xmlTextWriterWriteDtoLogMessageElementNS(writer, _dtoLogMessage, 1);
}

/**
 * Frees a DtoLogMessage.
 *
 * @param _dtoLogMessage The DtoLogMessage to free.
 */
void free_Grisu_dto_dtoLogMessage(struct Grisu_dto_dtoLogMessage *_dtoLogMessage) {
  freeDtoDtoLogMessageType(_dtoLogMessage);
  free(_dtoLogMessage);
}

/**
 * Reads a DtoLogMessage element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}logMessage", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoLogMessage, or NULL in case of error.
 */
struct Grisu_dto_dtoLogMessage *xmlTextReaderReadDtoLogMessageElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoLogMessage *_dtoLogMessage = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "logMessage", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}logMessage.\n");
#endif
    _dtoLogMessage = xmlTextReaderReadDtoDtoLogMessageType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoLogMessage == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}logMessage failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}logMessage failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoLogMessage;
}

/**
 * Writes a DtoLogMessage to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessage".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoLogMessage The DtoLogMessage to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoLogMessageElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessage *_dtoLogMessage) {
  return xmlTextWriterWriteDtoLogMessageElementNS(writer, _dtoLogMessage, 0);
}

/**
 * Writes a DtoLogMessage to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessage".
 *
 * @param writer The XML writer.
 * @param _dtoLogMessage The DtoLogMessage to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoLogMessageElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessage *_dtoLogMessage, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "logMessage", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}logMessage. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}logMessage...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoLogMessage for root element {http://api.grisu.arcs.org.au/dto}logMessage...\n");
#endif
  status = xmlTextWriterWriteDtoDtoLogMessageType(writer, _dtoLogMessage);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}logMessage. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}logMessage. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoLogMessage.
 *
 * @param _dtoLogMessage The DtoLogMessage whose children are to be free.
 */
static void freeDtoLogMessageElement(struct Grisu_dto_dtoLogMessage *_dtoLogMessage) {
  freeDtoDtoLogMessageType(_dtoLogMessage);
}

/**
 * Reads a DtoLogMessage from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoLogMessage, or NULL in case of error.
 */
static struct Grisu_dto_dtoLogMessage *xmlTextReaderReadDtoDtoLogMessageType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoLogMessage *_dtoLogMessage = calloc(1, sizeof(struct Grisu_dto_dtoLogMessage));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "date", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}dateTime from attribute {}date...\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateTimeType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}date of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
          freeDtoDtoLogMessageType(_dtoLogMessage);
          free(_dtoLogMessage);
          return NULL;
        }
        _dtoLogMessage->date = ((struct tm*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoLogMessageType(_dtoLogMessage);
      free(_dtoLogMessage);
      return NULL;
    }
  }

  if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from element value...\n");
#endif
    _child_accessor = xmlTextReaderReadXsStringType(reader);
    if (_child_accessor == NULL) {
      //panic: unable to return the value for some reason.
#if DEBUG_ENUNCIATE
      printf("Failed to read value of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
      freeDtoDtoLogMessageType(_dtoLogMessage);
      free(_dtoLogMessage);
      return NULL;
    }
    _dtoLogMessage->message = ((xmlChar*)_child_accessor);
  }
  else {
    _dtoLogMessage->message = BAD_CAST "";
  }


  return _dtoLogMessage;
}

/**
 * Writes a DtoLogMessage to XML.
 *
 * @param writer The XML writer.
 * @param _dtoLogMessage The DtoLogMessage to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoLogMessageType(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessage *_dtoLogMessage) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoLogMessage->date != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "date", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}date. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}dateTime for attribute {}date...\n");
#endif
    status = xmlTextWriterWriteXsDateTimeType(writer, (_dtoLogMessage->date));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}dateTime for attribute {}date. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}date. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoLogMessage->message != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element value...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoLogMessage->message));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element value. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoLogMessage.
 *
 * @param _dtoLogMessage The DtoLogMessage to free.
 */
static void freeDtoDtoLogMessageType(struct Grisu_dto_dtoLogMessage *_dtoLogMessage) {
  int i;
  if (_dtoLogMessage->date != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor date of type Grisu_dto_dtoLogMessage...\n");
#endif
    freeXsDateTimeType(_dtoLogMessage->date);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor date of type Grisu_dto_dtoLogMessage...\n");
#endif
    free(_dtoLogMessage->date);
  }
  if (_dtoLogMessage->message != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor message of type Grisu_dto_dtoLogMessage...\n");
#endif
    freeXsStringType(_dtoLogMessage->message);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor message of type Grisu_dto_dtoLogMessage...\n");
#endif
    free(_dtoLogMessage->message);
  }
}
#endif /* DEF_Grisu_dto_dtoLogMessage_M */
#ifndef DEF_Grisu_dto_dtoLogMessages_M
#define DEF_Grisu_dto_dtoLogMessages_M

/**
 * Reads a DtoLogMessages element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}logMessages", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoLogMessages, or NULL in case of error.
 */
struct Grisu_dto_dtoLogMessages *xml_read_Grisu_dto_dtoLogMessages(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoLogMessagesElement(reader);
}

/**
 * Writes a DtoLogMessages to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessages".
 *
 * @param writer The XML writer.
 * @param _dtoLogMessages The DtoLogMessages to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoLogMessages(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessages *_dtoLogMessages) {
  return xmlTextWriterWriteDtoLogMessagesElementNS(writer, _dtoLogMessages, 1);
}

/**
 * Frees a DtoLogMessages.
 *
 * @param _dtoLogMessages The DtoLogMessages to free.
 */
void free_Grisu_dto_dtoLogMessages(struct Grisu_dto_dtoLogMessages *_dtoLogMessages) {
  freeDtoDtoLogMessagesType(_dtoLogMessages);
  free(_dtoLogMessages);
}

/**
 * Reads a DtoLogMessages element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}logMessages", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoLogMessages, or NULL in case of error.
 */
struct Grisu_dto_dtoLogMessages *xmlTextReaderReadDtoLogMessagesElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoLogMessages *_dtoLogMessages = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "logMessages", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}logMessages.\n");
#endif
    _dtoLogMessages = xmlTextReaderReadDtoDtoLogMessagesType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoLogMessages == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}logMessages failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}logMessages failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoLogMessages;
}

/**
 * Writes a DtoLogMessages to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessages".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoLogMessages The DtoLogMessages to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoLogMessagesElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessages *_dtoLogMessages) {
  return xmlTextWriterWriteDtoLogMessagesElementNS(writer, _dtoLogMessages, 0);
}

/**
 * Writes a DtoLogMessages to XML under element name "{http://api.grisu.arcs.org.au/dto}logMessages".
 *
 * @param writer The XML writer.
 * @param _dtoLogMessages The DtoLogMessages to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoLogMessagesElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessages *_dtoLogMessages, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "logMessages", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}logMessages. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}logMessages...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoLogMessages for root element {http://api.grisu.arcs.org.au/dto}logMessages...\n");
#endif
  status = xmlTextWriterWriteDtoDtoLogMessagesType(writer, _dtoLogMessages);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}logMessages. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}logMessages. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoLogMessages.
 *
 * @param _dtoLogMessages The DtoLogMessages whose children are to be free.
 */
static void freeDtoLogMessagesElement(struct Grisu_dto_dtoLogMessages *_dtoLogMessages) {
  freeDtoDtoLogMessagesType(_dtoLogMessages);
}

/**
 * Reads a DtoLogMessages from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoLogMessages, or NULL in case of error.
 */
static struct Grisu_dto_dtoLogMessages *xmlTextReaderReadDtoDtoLogMessagesType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoLogMessages *_dtoLogMessages = calloc(1, sizeof(struct Grisu_dto_dtoLogMessages));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoLogMessagesType(_dtoLogMessages);
        free(_dtoLogMessages);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "message", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}message of type {http://api.grisu.arcs.org.au/dto}dtoLogMessage.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoLogMessageType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}message of type {http://api.grisu.arcs.org.au/dto}dtoLogMessage.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoLogMessagesType(_dtoLogMessages);
          free(_dtoLogMessages);
          return NULL;
        }

        _dtoLogMessages->messages = realloc(_dtoLogMessages->messages, (_dtoLogMessages->_sizeof_messages + 1) * sizeof(struct Grisu_dto_dtoLogMessage));
        memcpy(&(_dtoLogMessages->messages[_dtoLogMessages->_sizeof_messages++]), _child_accessor, sizeof(struct Grisu_dto_dtoLogMessage));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoLogMessages.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoLogMessages. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoLogMessages;
}

/**
 * Writes a DtoLogMessages to XML.
 *
 * @param writer The XML writer.
 * @param _dtoLogMessages The DtoLogMessages to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoLogMessagesType(xmlTextWriterPtr writer, struct Grisu_dto_dtoLogMessages *_dtoLogMessages) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _dtoLogMessages->_sizeof_messages; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "message", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}message. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoLogMessage for element {}message...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoLogMessageType(writer, &(_dtoLogMessages->messages[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoLogMessage for element {}message. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}message. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoLogMessages.
 *
 * @param _dtoLogMessages The DtoLogMessages to free.
 */
static void freeDtoDtoLogMessagesType(struct Grisu_dto_dtoLogMessages *_dtoLogMessages) {
  int i;
  if (_dtoLogMessages->messages != NULL) {
    for (i = 0; i < _dtoLogMessages->_sizeof_messages; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor messages[%i] of type Grisu_dto_dtoLogMessages...\n", i);
#endif
      freeDtoDtoLogMessageType(&(_dtoLogMessages->messages[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor messages of type Grisu_dto_dtoLogMessages...\n");
#endif
    free(_dtoLogMessages->messages);
  }
}
#endif /* DEF_Grisu_dto_dtoLogMessages_M */
#ifndef DEF_Grisu_dto_dtoMountPoints_M
#define DEF_Grisu_dto_dtoMountPoints_M

/**
 * Reads a DtoMountPoints element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}mountpoints", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoMountPoints, or NULL in case of error.
 */
struct Grisu_dto_dtoMountPoints *xml_read_Grisu_dto_dtoMountPoints(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoMountpointsElement(reader);
}

/**
 * Writes a DtoMountPoints to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoints".
 *
 * @param writer The XML writer.
 * @param _dtoMountPoints The DtoMountPoints to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoMountPoints(xmlTextWriterPtr writer, struct Grisu_dto_dtoMountPoints *_dtoMountPoints) {
  return xmlTextWriterWriteDtoMountpointsElementNS(writer, _dtoMountPoints, 1);
}

/**
 * Frees a DtoMountPoints.
 *
 * @param _dtoMountPoints The DtoMountPoints to free.
 */
void free_Grisu_dto_dtoMountPoints(struct Grisu_dto_dtoMountPoints *_dtoMountPoints) {
  freeDtoDtoMountPointsType(_dtoMountPoints);
  free(_dtoMountPoints);
}

/**
 * Reads a DtoMountPoints element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}mountpoints", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoMountPoints, or NULL in case of error.
 */
struct Grisu_dto_dtoMountPoints *xmlTextReaderReadDtoMountpointsElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoMountPoints *_dtoMountPoints = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "mountpoints", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}mountpoints.\n");
#endif
    _dtoMountPoints = xmlTextReaderReadDtoDtoMountPointsType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoMountPoints == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}mountpoints failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}mountpoints failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoMountPoints;
}

/**
 * Writes a DtoMountPoints to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoints".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoMountPoints The DtoMountPoints to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoMountpointsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoMountPoints *_dtoMountPoints) {
  return xmlTextWriterWriteDtoMountpointsElementNS(writer, _dtoMountPoints, 0);
}

/**
 * Writes a DtoMountPoints to XML under element name "{http://api.grisu.arcs.org.au/dto}mountpoints".
 *
 * @param writer The XML writer.
 * @param _dtoMountPoints The DtoMountPoints to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoMountpointsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoMountPoints *_dtoMountPoints, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "mountpoints", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}mountpoints. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}mountpoints...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoMountPoints for root element {http://api.grisu.arcs.org.au/dto}mountpoints...\n");
#endif
  status = xmlTextWriterWriteDtoDtoMountPointsType(writer, _dtoMountPoints);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}mountpoints. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}mountpoints. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoMountPoints.
 *
 * @param _dtoMountPoints The DtoMountPoints whose children are to be free.
 */
static void freeDtoMountpointsElement(struct Grisu_dto_dtoMountPoints *_dtoMountPoints) {
  freeDtoDtoMountPointsType(_dtoMountPoints);
}

/**
 * Reads a DtoMountPoints from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoMountPoints, or NULL in case of error.
 */
static struct Grisu_dto_dtoMountPoints *xmlTextReaderReadDtoDtoMountPointsType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoMountPoints *_dtoMountPoints = calloc(1, sizeof(struct Grisu_dto_dtoMountPoints));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoMountPointsType(_dtoMountPoints);
        free(_dtoMountPoints);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "mountpoint", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}mountpoint of type {http://api.grisu.arcs.org.au/dto}mountPoint.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoMountPointType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}mountpoint of type {http://api.grisu.arcs.org.au/dto}mountPoint.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoMountPointsType(_dtoMountPoints);
          free(_dtoMountPoints);
          return NULL;
        }

        _dtoMountPoints->mountpoints = realloc(_dtoMountPoints->mountpoints, (_dtoMountPoints->_sizeof_mountpoints + 1) * sizeof(struct Grisu_dto_mountPoint));
        memcpy(&(_dtoMountPoints->mountpoints[_dtoMountPoints->_sizeof_mountpoints++]), _child_accessor, sizeof(struct Grisu_dto_mountPoint));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoMountPoints.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoMountPoints. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoMountPoints;
}

/**
 * Writes a DtoMountPoints to XML.
 *
 * @param writer The XML writer.
 * @param _dtoMountPoints The DtoMountPoints to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoMountPointsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoMountPoints *_dtoMountPoints) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _dtoMountPoints->_sizeof_mountpoints; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "mountpoint", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}mountpoint. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}mountPoint for element {}mountpoint...\n", status);
#endif
    status = xmlTextWriterWriteDtoMountPointType(writer, &(_dtoMountPoints->mountpoints[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}mountPoint for element {}mountpoint. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}mountpoint. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoMountPoints.
 *
 * @param _dtoMountPoints The DtoMountPoints to free.
 */
static void freeDtoDtoMountPointsType(struct Grisu_dto_dtoMountPoints *_dtoMountPoints) {
  int i;
  if (_dtoMountPoints->mountpoints != NULL) {
    for (i = 0; i < _dtoMountPoints->_sizeof_mountpoints; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor mountpoints[%i] of type Grisu_dto_dtoMountPoints...\n", i);
#endif
      freeDtoMountPointType(&(_dtoMountPoints->mountpoints[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor mountpoints of type Grisu_dto_dtoMountPoints...\n");
#endif
    free(_dtoMountPoints->mountpoints);
  }
}
#endif /* DEF_Grisu_dto_dtoMountPoints_M */
#ifndef DEF_Grisu_dto_dtoMultiPartJobs_M
#define DEF_Grisu_dto_dtoMultiPartJobs_M

/**
 * Reads a DtoMultiPartJobs element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}multiPartJobs", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoMultiPartJobs, or NULL in case of error.
 */
struct Grisu_dto_dtoMultiPartJobs *xml_read_Grisu_dto_dtoMultiPartJobs(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoMultiPartJobsElement(reader);
}

/**
 * Writes a DtoMultiPartJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJobs".
 *
 * @param writer The XML writer.
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoMultiPartJobs(xmlTextWriterPtr writer, struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs) {
  return xmlTextWriterWriteDtoMultiPartJobsElementNS(writer, _dtoMultiPartJobs, 1);
}

/**
 * Frees a DtoMultiPartJobs.
 *
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to free.
 */
void free_Grisu_dto_dtoMultiPartJobs(struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs) {
  freeDtoDtoMultiPartJobsType(_dtoMultiPartJobs);
  free(_dtoMultiPartJobs);
}

/**
 * Reads a DtoMultiPartJobs element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}multiPartJobs", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoMultiPartJobs, or NULL in case of error.
 */
struct Grisu_dto_dtoMultiPartJobs *xmlTextReaderReadDtoMultiPartJobsElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "multiPartJobs", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}multiPartJobs.\n");
#endif
    _dtoMultiPartJobs = xmlTextReaderReadDtoDtoMultiPartJobsType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoMultiPartJobs == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}multiPartJobs failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}multiPartJobs failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoMultiPartJobs;
}

/**
 * Writes a DtoMultiPartJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJobs".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoMultiPartJobsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs) {
  return xmlTextWriterWriteDtoMultiPartJobsElementNS(writer, _dtoMultiPartJobs, 0);
}

/**
 * Writes a DtoMultiPartJobs to XML under element name "{http://api.grisu.arcs.org.au/dto}multiPartJobs".
 *
 * @param writer The XML writer.
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoMultiPartJobsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "multiPartJobs", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}multiPartJobs. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}multiPartJobs...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoMultiPartJobs for root element {http://api.grisu.arcs.org.au/dto}multiPartJobs...\n");
#endif
  status = xmlTextWriterWriteDtoDtoMultiPartJobsType(writer, _dtoMultiPartJobs);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}multiPartJobs. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}multiPartJobs. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoMultiPartJobs.
 *
 * @param _dtoMultiPartJobs The DtoMultiPartJobs whose children are to be free.
 */
static void freeDtoMultiPartJobsElement(struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs) {
  freeDtoDtoMultiPartJobsType(_dtoMultiPartJobs);
}

/**
 * Reads a DtoMultiPartJobs from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoMultiPartJobs, or NULL in case of error.
 */
static struct Grisu_dto_dtoMultiPartJobs *xmlTextReaderReadDtoDtoMultiPartJobsType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs = calloc(1, sizeof(struct Grisu_dto_dtoMultiPartJobs));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoMultiPartJobsType(_dtoMultiPartJobs);
        free(_dtoMultiPartJobs);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "multiPartJob", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}multiPartJob of type {http://api.grisu.arcs.org.au/dto}dtoBatchJob.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoBatchJobType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}multiPartJob of type {http://api.grisu.arcs.org.au/dto}dtoBatchJob.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoMultiPartJobsType(_dtoMultiPartJobs);
          free(_dtoMultiPartJobs);
          return NULL;
        }

        _dtoMultiPartJobs->allJobs = realloc(_dtoMultiPartJobs->allJobs, (_dtoMultiPartJobs->_sizeof_allJobs + 1) * sizeof(struct Grisu_dto_dtoBatchJob));
        memcpy(&(_dtoMultiPartJobs->allJobs[_dtoMultiPartJobs->_sizeof_allJobs++]), _child_accessor, sizeof(struct Grisu_dto_dtoBatchJob));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoMultiPartJobs.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoMultiPartJobs. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoMultiPartJobs;
}

/**
 * Writes a DtoMultiPartJobs to XML.
 *
 * @param writer The XML writer.
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoMultiPartJobsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _dtoMultiPartJobs->_sizeof_allJobs; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "multiPartJob", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}multiPartJob. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoBatchJob for element {}multiPartJob...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoBatchJobType(writer, &(_dtoMultiPartJobs->allJobs[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoBatchJob for element {}multiPartJob. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}multiPartJob. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoMultiPartJobs.
 *
 * @param _dtoMultiPartJobs The DtoMultiPartJobs to free.
 */
static void freeDtoDtoMultiPartJobsType(struct Grisu_dto_dtoMultiPartJobs *_dtoMultiPartJobs) {
  int i;
  if (_dtoMultiPartJobs->allJobs != NULL) {
    for (i = 0; i < _dtoMultiPartJobs->_sizeof_allJobs; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor allJobs[%i] of type Grisu_dto_dtoMultiPartJobs...\n", i);
#endif
      freeDtoDtoBatchJobType(&(_dtoMultiPartJobs->allJobs[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor allJobs of type Grisu_dto_dtoMultiPartJobs...\n");
#endif
    free(_dtoMultiPartJobs->allJobs);
  }
}
#endif /* DEF_Grisu_dto_dtoMultiPartJobs_M */
#ifndef DEF_Grisu_dto_dtoProperties_M
#define DEF_Grisu_dto_dtoProperties_M

/**
 * Reads a DtoProperties element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}userproperties", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoProperties, or NULL in case of error.
 */
struct Grisu_dto_dtoProperties *xml_read_Grisu_dto_dtoProperties(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoUserpropertiesElement(reader);
}

/**
 * Writes a DtoProperties to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperties".
 *
 * @param writer The XML writer.
 * @param _dtoProperties The DtoProperties to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoProperties(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperties *_dtoProperties) {
  return xmlTextWriterWriteDtoUserpropertiesElementNS(writer, _dtoProperties, 1);
}

/**
 * Frees a DtoProperties.
 *
 * @param _dtoProperties The DtoProperties to free.
 */
void free_Grisu_dto_dtoProperties(struct Grisu_dto_dtoProperties *_dtoProperties) {
  freeDtoDtoPropertiesType(_dtoProperties);
  free(_dtoProperties);
}

/**
 * Reads a DtoProperties element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}userproperties", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoProperties, or NULL in case of error.
 */
struct Grisu_dto_dtoProperties *xmlTextReaderReadDtoUserpropertiesElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoProperties *_dtoProperties = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "userproperties", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}userproperties.\n");
#endif
    _dtoProperties = xmlTextReaderReadDtoDtoPropertiesType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoProperties == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}userproperties failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}userproperties failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoProperties;
}

/**
 * Writes a DtoProperties to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperties".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoProperties The DtoProperties to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoUserpropertiesElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperties *_dtoProperties) {
  return xmlTextWriterWriteDtoUserpropertiesElementNS(writer, _dtoProperties, 0);
}

/**
 * Writes a DtoProperties to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperties".
 *
 * @param writer The XML writer.
 * @param _dtoProperties The DtoProperties to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoUserpropertiesElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperties *_dtoProperties, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "userproperties", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}userproperties. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}userproperties...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoProperties for root element {http://api.grisu.arcs.org.au/dto}userproperties...\n");
#endif
  status = xmlTextWriterWriteDtoDtoPropertiesType(writer, _dtoProperties);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}userproperties. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}userproperties. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoProperties.
 *
 * @param _dtoProperties The DtoProperties whose children are to be free.
 */
static void freeDtoUserpropertiesElement(struct Grisu_dto_dtoProperties *_dtoProperties) {
  freeDtoDtoPropertiesType(_dtoProperties);
}

/**
 * Reads a DtoProperties from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoProperties, or NULL in case of error.
 */
static struct Grisu_dto_dtoProperties *xmlTextReaderReadDtoDtoPropertiesType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoProperties *_dtoProperties = calloc(1, sizeof(struct Grisu_dto_dtoProperties));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoPropertiesType(_dtoProperties);
        free(_dtoProperties);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "userproperty", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}userproperty of type {http://api.grisu.arcs.org.au/dto}dtoProperty.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoPropertyType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}userproperty of type {http://api.grisu.arcs.org.au/dto}dtoProperty.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoPropertiesType(_dtoProperties);
          free(_dtoProperties);
          return NULL;
        }

        _dtoProperties->properties = realloc(_dtoProperties->properties, (_dtoProperties->_sizeof_properties + 1) * sizeof(struct Grisu_dto_dtoProperty));
        memcpy(&(_dtoProperties->properties[_dtoProperties->_sizeof_properties++]), _child_accessor, sizeof(struct Grisu_dto_dtoProperty));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoProperties.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoProperties. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoProperties;
}

/**
 * Writes a DtoProperties to XML.
 *
 * @param writer The XML writer.
 * @param _dtoProperties The DtoProperties to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoPropertiesType(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperties *_dtoProperties) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _dtoProperties->_sizeof_properties; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "userproperty", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}userproperty. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoProperty for element {}userproperty...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoPropertyType(writer, &(_dtoProperties->properties[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoProperty for element {}userproperty. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}userproperty. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoProperties.
 *
 * @param _dtoProperties The DtoProperties to free.
 */
static void freeDtoDtoPropertiesType(struct Grisu_dto_dtoProperties *_dtoProperties) {
  int i;
  if (_dtoProperties->properties != NULL) {
    for (i = 0; i < _dtoProperties->_sizeof_properties; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor properties[%i] of type Grisu_dto_dtoProperties...\n", i);
#endif
      freeDtoDtoPropertyType(&(_dtoProperties->properties[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor properties of type Grisu_dto_dtoProperties...\n");
#endif
    free(_dtoProperties->properties);
  }
}
#endif /* DEF_Grisu_dto_dtoProperties_M */
#ifndef DEF_Grisu_dto_dtoProperty_M
#define DEF_Grisu_dto_dtoProperty_M

/**
 * Reads a DtoProperty element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}userproperty", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoProperty, or NULL in case of error.
 */
struct Grisu_dto_dtoProperty *xml_read_Grisu_dto_dtoProperty(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoUserpropertyElement(reader);
}

/**
 * Writes a DtoProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperty".
 *
 * @param writer The XML writer.
 * @param _dtoProperty The DtoProperty to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoProperty(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperty *_dtoProperty) {
  return xmlTextWriterWriteDtoUserpropertyElementNS(writer, _dtoProperty, 1);
}

/**
 * Frees a DtoProperty.
 *
 * @param _dtoProperty The DtoProperty to free.
 */
void free_Grisu_dto_dtoProperty(struct Grisu_dto_dtoProperty *_dtoProperty) {
  freeDtoDtoPropertyType(_dtoProperty);
  free(_dtoProperty);
}

/**
 * Reads a DtoProperty element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}userproperty", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoProperty, or NULL in case of error.
 */
struct Grisu_dto_dtoProperty *xmlTextReaderReadDtoUserpropertyElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoProperty *_dtoProperty = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "userproperty", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}userproperty.\n");
#endif
    _dtoProperty = xmlTextReaderReadDtoDtoPropertyType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoProperty == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}userproperty failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}userproperty failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoProperty;
}

/**
 * Writes a DtoProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperty".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoProperty The DtoProperty to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoUserpropertyElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperty *_dtoProperty) {
  return xmlTextWriterWriteDtoUserpropertyElementNS(writer, _dtoProperty, 0);
}

/**
 * Writes a DtoProperty to XML under element name "{http://api.grisu.arcs.org.au/dto}userproperty".
 *
 * @param writer The XML writer.
 * @param _dtoProperty The DtoProperty to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoUserpropertyElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperty *_dtoProperty, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "userproperty", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}userproperty. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}userproperty...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoProperty for root element {http://api.grisu.arcs.org.au/dto}userproperty...\n");
#endif
  status = xmlTextWriterWriteDtoDtoPropertyType(writer, _dtoProperty);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}userproperty. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}userproperty. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoProperty.
 *
 * @param _dtoProperty The DtoProperty whose children are to be free.
 */
static void freeDtoUserpropertyElement(struct Grisu_dto_dtoProperty *_dtoProperty) {
  freeDtoDtoPropertyType(_dtoProperty);
}

/**
 * Reads a DtoProperty from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoProperty, or NULL in case of error.
 */
static struct Grisu_dto_dtoProperty *xmlTextReaderReadDtoDtoPropertyType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoProperty *_dtoProperty = calloc(1, sizeof(struct Grisu_dto_dtoProperty));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "key", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}key...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}key of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoPropertyType(_dtoProperty);
          free(_dtoProperty);
          return NULL;
        }
        _dtoProperty->key = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoPropertyType(_dtoProperty);
      free(_dtoProperty);
      return NULL;
    }
  }

  if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from element value...\n");
#endif
    _child_accessor = xmlTextReaderReadXsStringType(reader);
    if (_child_accessor == NULL) {
      //panic: unable to return the value for some reason.
#if DEBUG_ENUNCIATE
      printf("Failed to read value of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
      freeDtoDtoPropertyType(_dtoProperty);
      free(_dtoProperty);
      return NULL;
    }
    _dtoProperty->value = ((xmlChar*)_child_accessor);
  }
  else {
    _dtoProperty->value = BAD_CAST "";
  }


  return _dtoProperty;
}

/**
 * Writes a DtoProperty to XML.
 *
 * @param writer The XML writer.
 * @param _dtoProperty The DtoProperty to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoPropertyType(xmlTextWriterPtr writer, struct Grisu_dto_dtoProperty *_dtoProperty) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoProperty->key != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "key", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}key. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}key...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoProperty->key));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}key. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}key. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_dtoProperty->value != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element value...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoProperty->value));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element value. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoProperty.
 *
 * @param _dtoProperty The DtoProperty to free.
 */
static void freeDtoDtoPropertyType(struct Grisu_dto_dtoProperty *_dtoProperty) {
  int i;
  if (_dtoProperty->key != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor key of type Grisu_dto_dtoProperty...\n");
#endif
    freeXsStringType(_dtoProperty->key);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor key of type Grisu_dto_dtoProperty...\n");
#endif
    free(_dtoProperty->key);
  }
  if (_dtoProperty->value != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor value of type Grisu_dto_dtoProperty...\n");
#endif
    freeXsStringType(_dtoProperty->value);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor value of type Grisu_dto_dtoProperty...\n");
#endif
    free(_dtoProperty->value);
  }
}
#endif /* DEF_Grisu_dto_dtoProperty_M */
#ifndef DEF_Grisu_dto_dtoStringList_M
#define DEF_Grisu_dto_dtoStringList_M

/**
 * Reads a DtoStringList element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}list", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoStringList, or NULL in case of error.
 */
struct Grisu_dto_dtoStringList *xml_read_Grisu_dto_dtoStringList(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoListElement(reader);
}

/**
 * Writes a DtoStringList to XML under element name "{http://api.grisu.arcs.org.au/dto}list".
 *
 * @param writer The XML writer.
 * @param _dtoStringList The DtoStringList to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoStringList(xmlTextWriterPtr writer, struct Grisu_dto_dtoStringList *_dtoStringList) {
  return xmlTextWriterWriteDtoListElementNS(writer, _dtoStringList, 1);
}

/**
 * Frees a DtoStringList.
 *
 * @param _dtoStringList The DtoStringList to free.
 */
void free_Grisu_dto_dtoStringList(struct Grisu_dto_dtoStringList *_dtoStringList) {
  freeDtoDtoStringListType(_dtoStringList);
  free(_dtoStringList);
}

/**
 * Reads a DtoStringList element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}list", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoStringList, or NULL in case of error.
 */
struct Grisu_dto_dtoStringList *xmlTextReaderReadDtoListElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoStringList *_dtoStringList = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "list", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}list.\n");
#endif
    _dtoStringList = xmlTextReaderReadDtoDtoStringListType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoStringList == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}list failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}list failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoStringList;
}

/**
 * Writes a DtoStringList to XML under element name "{http://api.grisu.arcs.org.au/dto}list".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoStringList The DtoStringList to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoListElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoStringList *_dtoStringList) {
  return xmlTextWriterWriteDtoListElementNS(writer, _dtoStringList, 0);
}

/**
 * Writes a DtoStringList to XML under element name "{http://api.grisu.arcs.org.au/dto}list".
 *
 * @param writer The XML writer.
 * @param _dtoStringList The DtoStringList to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoListElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoStringList *_dtoStringList, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "list", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}list. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}list...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoStringList for root element {http://api.grisu.arcs.org.au/dto}list...\n");
#endif
  status = xmlTextWriterWriteDtoDtoStringListType(writer, _dtoStringList);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}list. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}list. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoStringList.
 *
 * @param _dtoStringList The DtoStringList whose children are to be free.
 */
static void freeDtoListElement(struct Grisu_dto_dtoStringList *_dtoStringList) {
  freeDtoDtoStringListType(_dtoStringList);
}

/**
 * Reads a DtoStringList from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoStringList, or NULL in case of error.
 */
static struct Grisu_dto_dtoStringList *xmlTextReaderReadDtoDtoStringListType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoStringList *_dtoStringList = calloc(1, sizeof(struct Grisu_dto_dtoStringList));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoStringListType(_dtoStringList);
        free(_dtoStringList);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "listElement", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}listElement of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}listElement of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoStringListType(_dtoStringList);
          free(_dtoStringList);
          return NULL;
        }

        _dtoStringList->stringList = realloc(_dtoStringList->stringList, (_dtoStringList->_sizeof_stringList + 1) * sizeof(xmlChar));
        memcpy(&(_dtoStringList->stringList[_dtoStringList->_sizeof_stringList++]), _child_accessor, sizeof(xmlChar));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoStringList.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoStringList. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoStringList;
}

/**
 * Writes a DtoStringList to XML.
 *
 * @param writer The XML writer.
 * @param _dtoStringList The DtoStringList to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoStringListType(xmlTextWriterPtr writer, struct Grisu_dto_dtoStringList *_dtoStringList) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _dtoStringList->_sizeof_stringList; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "listElement", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}listElement. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}listElement...\n", status);
#endif
    status = xmlTextWriterWriteXsStringType(writer, &(_dtoStringList->stringList[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}listElement. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}listElement. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoStringList.
 *
 * @param _dtoStringList The DtoStringList to free.
 */
static void freeDtoDtoStringListType(struct Grisu_dto_dtoStringList *_dtoStringList) {
  int i;
  if (_dtoStringList->stringList != NULL) {
    for (i = 0; i < _dtoStringList->_sizeof_stringList; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor stringList[%i] of type Grisu_dto_dtoStringList...\n", i);
#endif
      freeXsStringType(&(_dtoStringList->stringList[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor stringList of type Grisu_dto_dtoStringList...\n");
#endif
    free(_dtoStringList->stringList);
  }
}
#endif /* DEF_Grisu_dto_dtoStringList_M */
#ifndef DEF_Grisu_dto_dtoSubmissionLocationInfo_M
#define DEF_Grisu_dto_dtoSubmissionLocationInfo_M

/**
 * Reads a DtoSubmissionLocationInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}submissionlocation", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoSubmissionLocationInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoSubmissionLocationInfo *xml_read_Grisu_dto_dtoSubmissionLocationInfo(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoSubmissionlocationElement(reader);
}

/**
 * Writes a DtoSubmissionLocationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocation".
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoSubmissionLocationInfo(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo) {
  return xmlTextWriterWriteDtoSubmissionlocationElementNS(writer, _dtoSubmissionLocationInfo, 1);
}

/**
 * Frees a DtoSubmissionLocationInfo.
 *
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to free.
 */
void free_Grisu_dto_dtoSubmissionLocationInfo(struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo) {
  freeDtoDtoSubmissionLocationInfoType(_dtoSubmissionLocationInfo);
  free(_dtoSubmissionLocationInfo);
}

/**
 * Reads a DtoSubmissionLocationInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}submissionlocation", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoSubmissionLocationInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoSubmissionLocationInfo *xmlTextReaderReadDtoSubmissionlocationElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "submissionlocation", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}submissionlocation.\n");
#endif
    _dtoSubmissionLocationInfo = xmlTextReaderReadDtoDtoSubmissionLocationInfoType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoSubmissionLocationInfo == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}submissionlocation failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}submissionlocation failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoSubmissionLocationInfo;
}

/**
 * Writes a DtoSubmissionLocationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocation".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoSubmissionlocationElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo) {
  return xmlTextWriterWriteDtoSubmissionlocationElementNS(writer, _dtoSubmissionLocationInfo, 0);
}

/**
 * Writes a DtoSubmissionLocationInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocation".
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoSubmissionlocationElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "submissionlocation", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}submissionlocation. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}submissionlocation...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocationInfo for root element {http://api.grisu.arcs.org.au/dto}submissionlocation...\n");
#endif
  status = xmlTextWriterWriteDtoDtoSubmissionLocationInfoType(writer, _dtoSubmissionLocationInfo);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}submissionlocation. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}submissionlocation. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoSubmissionLocationInfo.
 *
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo whose children are to be free.
 */
static void freeDtoSubmissionlocationElement(struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo) {
  freeDtoDtoSubmissionLocationInfoType(_dtoSubmissionLocationInfo);
}

/**
 * Reads a DtoSubmissionLocationInfo from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoSubmissionLocationInfo, or NULL in case of error.
 */
static struct Grisu_dto_dtoSubmissionLocationInfo *xmlTextReaderReadDtoDtoSubmissionLocationInfoType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo = calloc(1, sizeof(struct Grisu_dto_dtoSubmissionLocationInfo));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "name", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}name...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoSubmissionLocationInfoType(_dtoSubmissionLocationInfo);
          free(_dtoSubmissionLocationInfo);
          return NULL;
        }
        _dtoSubmissionLocationInfo->submissionLocation = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoSubmissionLocationInfoType(_dtoSubmissionLocationInfo);
      free(_dtoSubmissionLocationInfo);
      return NULL;
    }
  }



  return _dtoSubmissionLocationInfo;
}

/**
 * Writes a DtoSubmissionLocationInfo to XML.
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoSubmissionLocationInfoType(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoSubmissionLocationInfo->submissionLocation != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "name", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}name...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoSubmissionLocationInfo->submissionLocation));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}name. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}name. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoSubmissionLocationInfo.
 *
 * @param _dtoSubmissionLocationInfo The DtoSubmissionLocationInfo to free.
 */
static void freeDtoDtoSubmissionLocationInfoType(struct Grisu_dto_dtoSubmissionLocationInfo *_dtoSubmissionLocationInfo) {
  int i;
  if (_dtoSubmissionLocationInfo->submissionLocation != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor submissionLocation of type Grisu_dto_dtoSubmissionLocationInfo...\n");
#endif
    freeXsStringType(_dtoSubmissionLocationInfo->submissionLocation);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor submissionLocation of type Grisu_dto_dtoSubmissionLocationInfo...\n");
#endif
    free(_dtoSubmissionLocationInfo->submissionLocation);
  }
}
#endif /* DEF_Grisu_dto_dtoSubmissionLocationInfo_M */
#ifndef DEF_Grisu_dto_dtoSubmissionLocations_M
#define DEF_Grisu_dto_dtoSubmissionLocations_M

/**
 * Reads a DtoSubmissionLocations element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}submissionlocations", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoSubmissionLocations, or NULL in case of error.
 */
struct Grisu_dto_dtoSubmissionLocations *xml_read_Grisu_dto_dtoSubmissionLocations(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoSubmissionlocationsElement(reader);
}

/**
 * Writes a DtoSubmissionLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocations".
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoSubmissionLocations(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations) {
  return xmlTextWriterWriteDtoSubmissionlocationsElementNS(writer, _dtoSubmissionLocations, 1);
}

/**
 * Frees a DtoSubmissionLocations.
 *
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to free.
 */
void free_Grisu_dto_dtoSubmissionLocations(struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations) {
  freeDtoDtoSubmissionLocationsType(_dtoSubmissionLocations);
  free(_dtoSubmissionLocations);
}

/**
 * Reads a DtoSubmissionLocations element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}submissionlocations", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoSubmissionLocations, or NULL in case of error.
 */
struct Grisu_dto_dtoSubmissionLocations *xmlTextReaderReadDtoSubmissionlocationsElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "submissionlocations", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}submissionlocations.\n");
#endif
    _dtoSubmissionLocations = xmlTextReaderReadDtoDtoSubmissionLocationsType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoSubmissionLocations == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}submissionlocations failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}submissionlocations failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoSubmissionLocations;
}

/**
 * Writes a DtoSubmissionLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocations".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoSubmissionlocationsElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations) {
  return xmlTextWriterWriteDtoSubmissionlocationsElementNS(writer, _dtoSubmissionLocations, 0);
}

/**
 * Writes a DtoSubmissionLocations to XML under element name "{http://api.grisu.arcs.org.au/dto}submissionlocations".
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoSubmissionlocationsElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "submissionlocations", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}submissionlocations. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}submissionlocations...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocations for root element {http://api.grisu.arcs.org.au/dto}submissionlocations...\n");
#endif
  status = xmlTextWriterWriteDtoDtoSubmissionLocationsType(writer, _dtoSubmissionLocations);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}submissionlocations. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}submissionlocations. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoSubmissionLocations.
 *
 * @param _dtoSubmissionLocations The DtoSubmissionLocations whose children are to be free.
 */
static void freeDtoSubmissionlocationsElement(struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations) {
  freeDtoDtoSubmissionLocationsType(_dtoSubmissionLocations);
}

/**
 * Reads a DtoSubmissionLocations from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoSubmissionLocations, or NULL in case of error.
 */
static struct Grisu_dto_dtoSubmissionLocations *xmlTextReaderReadDtoDtoSubmissionLocationsType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations = calloc(1, sizeof(struct Grisu_dto_dtoSubmissionLocations));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoSubmissionLocationsType(_dtoSubmissionLocations);
        free(_dtoSubmissionLocations);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "submissionlocation", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}submissionlocation of type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocationInfo.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoSubmissionLocationInfoType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}submissionlocation of type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocationInfo.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoSubmissionLocationsType(_dtoSubmissionLocations);
          free(_dtoSubmissionLocations);
          return NULL;
        }

        _dtoSubmissionLocations->allSubmissionLocations = realloc(_dtoSubmissionLocations->allSubmissionLocations, (_dtoSubmissionLocations->_sizeof_allSubmissionLocations + 1) * sizeof(struct Grisu_dto_dtoSubmissionLocationInfo));
        memcpy(&(_dtoSubmissionLocations->allSubmissionLocations[_dtoSubmissionLocations->_sizeof_allSubmissionLocations++]), _child_accessor, sizeof(struct Grisu_dto_dtoSubmissionLocationInfo));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocations.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocations. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoSubmissionLocations;
}

/**
 * Writes a DtoSubmissionLocations to XML.
 *
 * @param writer The XML writer.
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoSubmissionLocationsType(xmlTextWriterPtr writer, struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _dtoSubmissionLocations->_sizeof_allSubmissionLocations; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "submissionlocation", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}submissionlocation. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocationInfo for element {}submissionlocation...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoSubmissionLocationInfoType(writer, &(_dtoSubmissionLocations->allSubmissionLocations[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocationInfo for element {}submissionlocation. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}submissionlocation. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoSubmissionLocations.
 *
 * @param _dtoSubmissionLocations The DtoSubmissionLocations to free.
 */
static void freeDtoDtoSubmissionLocationsType(struct Grisu_dto_dtoSubmissionLocations *_dtoSubmissionLocations) {
  int i;
  if (_dtoSubmissionLocations->allSubmissionLocations != NULL) {
    for (i = 0; i < _dtoSubmissionLocations->_sizeof_allSubmissionLocations; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor allSubmissionLocations[%i] of type Grisu_dto_dtoSubmissionLocations...\n", i);
#endif
      freeDtoDtoSubmissionLocationInfoType(&(_dtoSubmissionLocations->allSubmissionLocations[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor allSubmissionLocations of type Grisu_dto_dtoSubmissionLocations...\n");
#endif
    free(_dtoSubmissionLocations->allSubmissionLocations);
  }
}
#endif /* DEF_Grisu_dto_dtoSubmissionLocations_M */
#ifndef DEF_Grisu_dto_dtoVersionInfo_M
#define DEF_Grisu_dto_dtoVersionInfo_M

/**
 * Reads a DtoVersionInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}version", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The DtoVersionInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoVersionInfo *xml_read_Grisu_dto_dtoVersionInfo(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadDtoVersionElement(reader);
}

/**
 * Writes a DtoVersionInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}version".
 *
 * @param writer The XML writer.
 * @param _dtoVersionInfo The DtoVersionInfo to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_Grisu_dto_dtoVersionInfo(xmlTextWriterPtr writer, struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo) {
  return xmlTextWriterWriteDtoVersionElementNS(writer, _dtoVersionInfo, 1);
}

/**
 * Frees a DtoVersionInfo.
 *
 * @param _dtoVersionInfo The DtoVersionInfo to free.
 */
void free_Grisu_dto_dtoVersionInfo(struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo) {
  freeDtoDtoVersionInfoType(_dtoVersionInfo);
  free(_dtoVersionInfo);
}

/**
 * Reads a DtoVersionInfo element from XML. The element to be read is "{http://api.grisu.arcs.org.au/dto}version", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The DtoVersionInfo, or NULL in case of error.
 */
struct Grisu_dto_dtoVersionInfo *xmlTextReaderReadDtoVersionElement(xmlTextReaderPtr reader) {
  struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "version", xmlTextReaderConstLocalName(reader)) == 0
    && xmlStrcmp(BAD_CAST "http://api.grisu.arcs.org.au/dto", xmlTextReaderConstNamespaceUri(reader)) == 0) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {http://api.grisu.arcs.org.au/dto}version.\n");
#endif
    _dtoVersionInfo = xmlTextReaderReadDtoDtoVersionInfoType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_dtoVersionInfo == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}version failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {http://api.grisu.arcs.org.au/dto}version failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _dtoVersionInfo;
}

/**
 * Writes a DtoVersionInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}version".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _dtoVersionInfo The DtoVersionInfo to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoVersionElement(xmlTextWriterPtr writer, struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo) {
  return xmlTextWriterWriteDtoVersionElementNS(writer, _dtoVersionInfo, 0);
}

/**
 * Writes a DtoVersionInfo to XML under element name "{http://api.grisu.arcs.org.au/dto}version".
 *
 * @param writer The XML writer.
 * @param _dtoVersionInfo The DtoVersionInfo to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteDtoVersionElementNS(xmlTextWriterPtr writer, struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, BAD_CAST "dto", BAD_CAST "version", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {http://api.grisu.arcs.org.au/dto}version. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  if (writeNamespaces) {
#if DEBUG_ENUNCIATE > 1
    printf("writing namespaces for start element {http://api.grisu.arcs.org.au/dto}version...\n");
#endif

    status = xmlTextWriterWriteAttribute(writer, BAD_CAST "xmlns:dto", BAD_CAST "http://api.grisu.arcs.org.au/dto");
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("unable to write namespace attribute xmlns:dto. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

#if DEBUG_ENUNCIATE > 1
  printf("writing type {http://api.grisu.arcs.org.au/dto}dtoVersionInfo for root element {http://api.grisu.arcs.org.au/dto}version...\n");
#endif
  status = xmlTextWriterWriteDtoDtoVersionInfoType(writer, _dtoVersionInfo);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {http://api.grisu.arcs.org.au/dto}version. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {http://api.grisu.arcs.org.au/dto}version. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a DtoVersionInfo.
 *
 * @param _dtoVersionInfo The DtoVersionInfo whose children are to be free.
 */
static void freeDtoVersionElement(struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo) {
  freeDtoDtoVersionInfoType(_dtoVersionInfo);
}

/**
 * Reads a DtoVersionInfo from XML. The reader is assumed to be at the start element.
 *
 * @return the DtoVersionInfo, or NULL in case of error.
 */
static struct Grisu_dto_dtoVersionInfo *xmlTextReaderReadDtoDtoVersionInfoType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo = calloc(1, sizeof(struct Grisu_dto_dtoVersionInfo));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "name", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}name...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeDtoDtoVersionInfoType(_dtoVersionInfo);
          free(_dtoVersionInfo);
          return NULL;
        }
        _dtoVersionInfo->name = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeDtoDtoVersionInfoType(_dtoVersionInfo);
      free(_dtoVersionInfo);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeDtoDtoVersionInfoType(_dtoVersionInfo);
        free(_dtoVersionInfo);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "submissionlocation", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}submissionlocation of type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocations.\n");
#endif
        _child_accessor = xmlTextReaderReadDtoDtoSubmissionLocationsType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}submissionlocation of type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocations.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeDtoDtoVersionInfoType(_dtoVersionInfo);
          free(_dtoVersionInfo);
          return NULL;
        }

        _dtoVersionInfo->allSubmissionLocations = ((struct Grisu_dto_dtoSubmissionLocations*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {http://api.grisu.arcs.org.au/dto}dtoVersionInfo.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {http://api.grisu.arcs.org.au/dto}dtoVersionInfo. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _dtoVersionInfo;
}

/**
 * Writes a DtoVersionInfo to XML.
 *
 * @param writer The XML writer.
 * @param _dtoVersionInfo The DtoVersionInfo to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteDtoDtoVersionInfoType(xmlTextWriterPtr writer, struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_dtoVersionInfo->name != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "name", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}name...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_dtoVersionInfo->name));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}name. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}name. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_dtoVersionInfo->allSubmissionLocations != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "submissionlocation", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}submissionlocation. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocations for element {}submissionlocation...\n", status);
#endif
    status = xmlTextWriterWriteDtoDtoSubmissionLocationsType(writer, (_dtoVersionInfo->allSubmissionLocations));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://api.grisu.arcs.org.au/dto}dtoSubmissionLocations for element {}submissionlocation. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}submissionlocation. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a DtoVersionInfo.
 *
 * @param _dtoVersionInfo The DtoVersionInfo to free.
 */
static void freeDtoDtoVersionInfoType(struct Grisu_dto_dtoVersionInfo *_dtoVersionInfo) {
  int i;
  if (_dtoVersionInfo->name != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor name of type Grisu_dto_dtoVersionInfo...\n");
#endif
    freeXsStringType(_dtoVersionInfo->name);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor name of type Grisu_dto_dtoVersionInfo...\n");
#endif
    free(_dtoVersionInfo->name);
  }
  if (_dtoVersionInfo->allSubmissionLocations != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor allSubmissionLocations of type Grisu_dto_dtoVersionInfo...\n");
#endif
    freeDtoDtoSubmissionLocationsType(_dtoVersionInfo->allSubmissionLocations);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor allSubmissionLocations of type Grisu_dto_dtoVersionInfo...\n");
#endif
    free(_dtoVersionInfo->allSubmissionLocations);
  }
}
#endif /* DEF_Grisu_dto_dtoVersionInfo_M */
